# $Id: footer.kmk 2432 2010-11-29 16:50:27Z bird $
## @file
# kBuild - File included at top of makefile.
#

#
# Copyright (c) 2004-2010 knut st. osmundsen <bird-kBuild-spamx@anduin.net>
#
# This file is part of kBuild.
#
# kBuild is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version source of the License, or
# (at your option) any later version.
#
# kBuild is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with kBuild; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# As a special exception you are granted permission to include this file, via
# the kmk include directive, as you wish without this in itself causing the
# resulting makefile, program or whatever to be covered by the GPL license.
# This exception does not however invalidate any other reasons why the makefile,
# program, whatever should not be covered the GPL.
#
#

ifndef __footer_kmk__
# start-of-file-content
ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, start of footer.kmk)
 _KBUILD_TS_FOOTER_START := $(_KBUILD_TS_PREV)
endif

#
# Variables.
# (Some of these need initialization before including definitions using them.)
#

# All targets of each types.
_ALL_BLDPROGS    := $(BLDPROGS)    $(BLDPROGS.$(KBUILD_HOST))        $(BLDPROGS.$(KBUILD_HOST).$(KBUILD_HOST_ARCH))            $(BLDPROGS.$(KBUILD_HOST_ARCH))      $(BLDPROGS.$(KBUILD_HOST_CPU))       $(BLDPROGS.$(KBUILD_TYPE))
_ALL_LIBRARIES   := $(LIBRARIES)   $(LIBRARIES.$(KBUILD_TARGET))     $(LIBRARIES.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))       $(LIBRARIES.$(KBUILD_TARGET_ARCH))   $(LIBRARIES.$(KBUILD_TARGET_CPU))    $(LIBRARIES.$(KBUILD_TYPE))
_ALL_IMPORT_LIBS := $(IMPORT_LIBS) $(IMPORT_LIBS.$(KBUILD_TARGET))   $(IMPORT_LIBS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))     $(IMPORT_LIBS.$(KBUILD_TARGET_ARCH)) $(IMPORT_LIBS.$(KBUILD_TARGET_CPU))  $(IMPORT_LIBS.$(KBUILD_TYPE))
_ALL_DLLS        := $(DLLS)        $(DLLS.$(KBUILD_TARGET))          $(DLLS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))            $(DLLS.$(KBUILD_TARGET_ARCH))        $(DLLS.$(KBUILD_TARGET_CPU))         $(DLLS.$(KBUILD_TYPE))
_ALL_PROGRAMS    := $(PROGRAMS)    $(PROGRAMS.$(KBUILD_TARGET))      $(PROGRAMS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))        $(PROGRAMS.$(KBUILD_TARGET_ARCH))    $(PROGRAMS.$(KBUILD_TARGET_CPU))     $(PROGRAMS.$(KBUILD_TYPE))
_ALL_SYSMODS     := $(SYSMODS)     $(SYSMODS.$(KBUILD_TARGET))       $(SYSMODS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))         $(SYSMODS.$(KBUILD_TARGET_ARCH))     $(SYSMODS.$(KBUILD_TARGET_CPU))      $(SYSMODS.$(KBUILD_TYPE))
_ALL_MISCBINS    := $(MISCBINS)    $(MISCBINS.$(KBUILD_TARGET))      $(MISCBINS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))        $(MISCBINS.$(KBUILD_TARGET_ARCH))    $(MISCBINS.$(KBUILD_TARGET_CPU))     $(MISCBINS.$(KBUILD_TYPE))
_ALL_OTHERS      := $(OTHERS)      $(OTHERS.$(KBUILD_TARGET))        $(OTHERS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))          $(OTHERS.$(KBUILD_TARGET_ARCH))      $(OTHERS.$(KBUILD_TARGET_CPU))       $(OTHERS.$(KBUILD_TYPE))
_ALL_INSTALLS    := $(INSTALLS)    $(INSTALLS.$(KBUILD_TARGET))      $(INSTALLS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))        $(INSTALLS.$(KBUILD_TARGET_ARCH))    $(INSTALLS.$(KBUILD_TARGET_CPU))     $(INSTALLS.$(KBUILD_TYPE))
_ALL_FETCHES     := $(FETCHES)     $(FETCHES.$(KBUILD_TARGET))       $(FETCHES.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))         $(FETCHES.$(KBUILD_TARGET_ARCH))     $(FETCHES.$(KBUILD_TARGET_CPU))      $(FETCHES.$(KBUILD_TYPE))
_ALL_PATCHES     := $(PATCHES)     $(PATCHES.$(KBUILD_TARGET))       $(PATCHES.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))         $(PATCHES.$(KBUILD_TARGET_ARCH))     $(PATCHES.$(KBUILD_TARGET_CPU))      $(PATCHES.$(KBUILD_TYPE))

# all targets.
_ALL_TARGETS = \
	$(_ALL_FETCHES) \
	$(_ALL_PATCHES) \
	$(_ALL_BLDPROGS) \
	$(_ALL_LIBRARIES) \
	$(_ALL_IMPORT_LIBS) \
	$(_ALL_DLLS) \
	$(_ALL_PROGRAMS) \
	$(_ALL_SYSMODS) \
	$(_ALL_MISCBINS) \
	$(_ALL_INSTALLS) \
	$(_ALL_OTHERS)

# all $(KBUILD_TARGET) targets.
_ALL_TARGET_TARGETS = \
	$(_ALL_FETCHES) \
	$(_ALL_PATCHES) \
	$(_ALL_LIBRARIES) \
	$(_ALL_IMPORT_LIBS) \
	$(_ALL_DLLS) \
	$(_ALL_PROGRAMS) \
	$(_ALL_SYSMODS) \
	$(_ALL_MISCBINS) \
	$(_ALL_INSTALLS) \
	$(_ALL_OTHERS)

# all $(KBUILD_HOST) targets.
_ALL_HOST_TARGETS = \
	$(_ALL_BLDPROGS)

# all targets making use of srcname.
_ALL_SRCNAME_TARGETS = \
	$(_ALL_FETCHES) \
	$(_ALL_PATCHES)

# Dependency files. (currently not on target level, only this global stuff)
_DEPFILES        := $(DEPFILES)    $(DEPFILES.$(KBUILD_TARGET))      $(DEPFILES.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))        $(DEPFILES.$(KBUILD_TARGET_ARCH))    $(DEPFILES.$(KBUILD_TARGET_CPU))     $(DEPFILES.$(KBUILD_TYPE))

# included dependency files.
_DEPFILES_INCLUDED :=


# All kind of output files except for _OBJS and _DEPFILES.
# Compiling or linking definition outputting other things that $@ and any
# required dependency file must add those output files to this variable.
_OUT_FILES :=

# Files which only requires cleaning up.
_CLEAN_FILES :=

# all of a type
_OBJS     :=
_FETCHES  :=
_DOWNLOADS:=
_UNPACKS  :=
_PATCHES  :=
_UNFETCHES:=
_BLDPROGS :=
_LIBS     :=
_DLLS     :=
_PROGRAMS :=
_SYSMODS  :=
_MISCBINS :=
_INSTALLS :=
_INSTALLS_FILES :=
_INSTALLS_DIRS :=
_OTHERS   :=
_PACKING  :=
_DIRS     := $(PATH_TARGET)/ $(PATH_TARGET) $(BLDDIRS)
_IMPORT_LIBS :=

# misc
pass_prev :=



#
# Footer macros
#

## Figure out the tool for a target.
# @param    $1           normalized target.
# @param    $2           tooltype.
# @param    bld_trg      build target.
# @param    bld_trg_arch build target architecture.
_TARGET_TOOL = $(strip $(firstword \
	$($(1)_$(2)TOOL.$(bld_trg).$(bld_trg_arch)) \
	$($(1)_$(2)TOOL.$(bld_trg)) \
	$($(1)_$(2)TOOL) \
	$($(1)_TOOL.$(bld_trg).$(bld_trg_arch)) \
	$($(1)_TOOL.$(bld_trg)) \
	$($(1)_TOOL) \
	$($(2)TOOL.$(bld_trg).$(bld_trg_arch)) \
	$($(2)TOOL.$(bld_trg)) \
	$($(2)TOOL) \
	$(TOOL.$(bld_trg).$(bld_trg_arch)) \
	$(TOOL.$(bld_trg)) \
	$(TOOL) \
	))

## Figure out the actual name of an installed file.
# @param	$1		The file to install.
# @param	$2		The target name.
# @param	$3		The _INST value (can be empty).
# @param	$4		The default directory to use when $3 is empty.
_INSTALL_FILE = $(patsubst %/,%/$(notdir $(1)),$(if $(3),$(PATH_INS)/$(3),$(4)/))



## Converts a variable from simple to recursive flavor.
# This is used by def_inherit_template_one_accumulate_l and def_inherit_template_one_accumulate_r.
# @param    $1              The variable name.
define def_simple_2_recursive
$1_DEFERRED := $$($1)
$1 = $$($1_DEFERRED)
endef


## Inherit one keyword in a non-accumulative manner.
# @param    $(trg)          Target object.
# @param    $(prop)     	The property.
# @param    $(src_key)      Source keyword.
# @param    $(trg_key)      Target keyword.
define def_inherit_one_keyword
ifdef $(trg)_$(prop).$(src_key)
 ifndef $(trg)_$(prop).$(trg_key)
  $(trg)_$(prop).$(trg_key) = $($(trg)_$(prop).$(src_key))
 endif
endif
endef


# EXPAND_BY = overriding

## Inherit one keyword in a non-accumulative manner.
# @param    $(trg)          Target object.
# @param    $(prop)     	The property.
# @param    $(src_key)      Source keyword.
# @param    $(trg_key)      Target keyword.
define def_inherit_one_keyword_overriding_now_l
ifdef $(trg)_$(prop).$(src_key)
 ifndef $(trg)_$(prop).$(trg_key)
  $(trg)_$(prop).$(trg_key) := $($(trg)_$(prop).$(src_key))
 endif
endif
endef

## @copydoc def_inherit_one_overriding_now_l
define def_inherit_one_keyword_overriding_now_r
ifdef $(trg)_$(prop).$(src_key)
 ifndef $(trg)_$(prop).$(trg_key)
  $(trg)_$(prop).$(trg_key) := $($(trg)_$(prop).$(src_key))
 endif
endif
endef

## Inherit one keyword in a non-accumulative manner, deferred expansion.
# @param    $(trg)          Target object.
# @param    $(prop)     	The property.
# @param    $(src_key)      Source keyword.
# @param    $(trg_key)      Target keyword.
# @remark This define relies on double evaluation
define def_inherit_one_keyword_overriding_deferred
ifdef $(trg)_$(prop).$(src_key)
 ifndef $(trg)_$(prop).$(trg_key)
  $(trg)_$(prop).$(trg_key) = $$($(trg)_$(prop).$(src_key))
 endif
endif
endef

## @copydoc def_inherit_one_overriding_deferred
define def_inherit_one_keyword_overriding_deferred_l
ifdef $(trg)_$(prop).$(src_key)
 ifndef $(trg)_$(prop).$(trg_key)
  $(trg)_$(prop).$(trg_key) = $$($(trg)_$(prop).$(src_key))
 endif
endif
endef

## @copydoc def_inherit_one_overriding_deferred
define def_inherit_one_keyword_overriding_deferred_r
ifdef $(trg)_$(prop).$(src_key)
 ifndef $(trg)_$(prop).$(trg_key)
  $(trg)_$(prop).$(trg_key) = $$($(trg)_$(prop).$(src_key))
 endif
endif
endef


# EXPAND_BY = prepending

## Inherit one keyword in a prepending manner.
# @param    $(trg)          Target object.
# @param    $(prop)     	The property.
# @param    $(src_key)      Source keyword.
# @param    $(trg_key)      Target keyword.
define def_inherit_one_keyword_prepending_now_l
ifdef $(trg)_$(prop).$(src_key)
 $(trg)_$(prop).$(trg_key) := $($(trg)_$(prop).$(src_key)) $($(trg)_$(prop).$(trg_key))
endif
endef

## @copydoc def_inherit_one_prepending_now_l
define def_inherit_one_keyword_prepending_now_r
ifdef $(trg)_$(prop).$(src_key)
 $(trg)_$(prop).$(trg_key) := $($(trg)_$(prop).$(trg_key)) $($(trg)_$(prop).$(src_key))
endif
endef

## Inherit one keyword in a non-accumulative manner, deferred expansion.
# @param    $(trg)          Target object.
# @param    $(prop)     	The property.
# @param    $(src_key)      Source keyword.
# @param    $(trg_key)      Target keyword.
# @remark This define relies on double evaluation
define def_inherit_one_keyword_prepending_deferred
ifdef $(trg)_$(prop).$(src_key)
 ifndef $(trg)_$(prop).$(trg_key)
  $(trg)_$(prop).$(trg_key) = $$($(trg)_$(prop).$(src_key))
 endif
endif
endef

## Inherit one keyword in a prepending manner, deferred expansion.
# @param    $(trg)          Target object.
# @param    $(prop)     	The property.
# @param    $(src_key)      Source keyword.
# @param    $(trg_key)      Target keyword.
define def_inherit_one_keyword_prepending_deferred_l
ifdef $(trg)_$(prop).$(src_key)
 ifeq ($$(flavor $(trg)_$(prop).$(trg_key)),simple)
  $$(evalcall2 def_simple_2_recursive,$(trg)_$(prop).$(trg_key))
 endif
 $(trg)_$(prop).$(trg_key) <= $$($(trg)_$(prop).$(src_key))
endif
endef

## @copydoc def_inherit_one_prepending_deferred_l
define def_inherit_one_keyword_prepending_deferred_r
ifdef $(trg)_$(prop).$(src_key)
 ifeq ($$(flavor $(trg)_$(prop).$(trg_key)),simple)
  $$(evalcall2 def_simple_2_recursive,$(trg)_$(prop).$(trg_key))
 endif
 $(trg)_$(prop).$(trg_key) += $$($(trg)_$(prop).$(src_key))
endif
endef


# EXPAND_BY = appending

## Inherit one keyword in an appending manner.
# @param    $(trg)          Target object.
# @param    $(prop)     	The property.
# @param    $(src_key)      Source keyword.
# @param    $(trg_key)      Target keyword.
define def_inherit_one_keyword_appending_now_l
ifdef $(trg)_$(prop).$(src_key)
 $(trg)_$(prop).$(trg_key) := $($(trg)_$(prop).$(trg_key)) $($(trg)_$(prop).$(src_key))
endif
endef

## @copydoc def_inherit_one_appending_now_l
define def_inherit_one_keyword_appending_now_r
ifdef $(trg)_$(prop).$(src_key)
 $(trg)_$(prop).$(trg_key) := $($(trg)_$(prop).$(src_key)) $($(trg)_$(prop).$(trg_key))
endif
endef

## Inherit one keyword in a non-accumulative manner, deferred expansion.
# @param    $(trg)          Target object.
# @param    $(prop)     	The property.
# @param    $(src_key)      Source keyword.
# @param    $(trg_key)      Target keyword.
# @remark This define relies on double evaluation
define def_inherit_one_keyword_appending_deferred
ifdef $(trg)_$(prop).$(src_key)
 ifndef $(trg)_$(prop).$(trg_key)
  $(trg)_$(prop).$(trg_key) = $$($(trg)_$(prop).$(src_key))
 endif
endif
endef

## Inherit one keyword in an appending manner, deferred expansion.
# @param    $(trg)          Target object.
# @param    $(prop)     	The property.
# @param    $(src_key)      Source keyword.
# @param    $(trg_key)      Target keyword.
define def_inherit_one_keyword_appending_deferred_l
ifdef $(trg)_$(prop).$(src_key)
 ifeq ($$(flavor $(trg)_$(prop).$(trg_key)),simple)
  $$(evalcall2 def_simple_2_recursive,$(trg)_$(prop).$(trg_key))
 endif
 $(trg)_$(prop).$(trg_key) += $$($(trg)_$(prop).$(src_key))
endif
endef

## @copydoc def_inherit_one_appending_deferred_l
define def_inherit_one_keyword_appending_deferred_r
ifdef $(trg)_$(prop).$(src_key)
 ifeq ($$(flavor $(trg)_$(prop).$(trg_key)),simple)
  $$(evalcall2 def_simple_2_recursive,$(trg)_$(prop).$(trg_key))
 endif
 $(trg)_$(prop).$(trg_key) <= $$($(trg)_$(prop).$(src_key))
endif
endef


## Worker for def_inherit that deals with one keyword that makes
# use of inheritance.
# @param    prefix_keyword        key_prefix:keyword. The cool join/split game as usual.
# @param    trg                   Object to consider for inheriting.
# @param    properties            List of the properties with straight expansion.
# @param    properties_now_l      List of the properties with immediate expansion, accumulating on the left side.
# @param    properties_now_r      List of the properties with immediate expansion, accumulating on the right side.
# @param    properties_deferred   List of the properties with deferred expansion (e.g. function), non-accumulative .
# @param    properties_deferred_l List of the properties with deferred expansion (e.g. function), accumulating on the left side.
# @param    properties_deferred_r List of the properties with deferred expansion (e.g. function), accumulating on the right side.
define def_inherit_keyword
local prefix   := $(word 1,$(subst :, ,$(prefix_keyword)))
local trg_key  := $(word 2,$(subst :, ,$(prefix_keyword)))
local src_key  := $($(prefix)_$(trg_key)_EXTENDS)
local by       := $($(prefix)_$(trg_key)_EXTENDS_BY)

# Inherit the properties.
$(foreach prop, $(properties),            $(eval $(def_inherit_one_keyword)))
$(foreach prop, $(properties_now_l),      $(eval $(def_inherit_one_keyword_$(by)_now_l)))
$(foreach prop, $(properties_now_r),      $(eval $(def_inherit_one_keyword_$(by)_now_r)))
$(foreach prop, $(properties_deferred),   $(eval $(def_inherit_one_keyword_$(by)_deferred)))
$(foreach prop, $(properties_deferred_l), $(eval $(def_inherit_one_keyword_$(by)_deferred_l)))
$(foreach prop, $(properties_deferred_r), $(eval $(def_inherit_one_keyword_$(by)_deferred_r)))

endef # def_inherit_keyword


## Inherit one template property in a non-accumulative manner.
# @param    $(prop)         Property name
# @param    $(src)          Source (parent) object.
# @param    $(trg)          Target (child) object.
define def_inherit_one
ifdef $(src)_$(prop)
 ifndef $(trg)_$(prop)
  $(trg)_$(prop) = $($(src)_$(prop))
 endif
endif
endef


# EXPAND_BY = overriding

## Inherit one template property in a non-accumulative manner.
# @param    $(prop)         Property name
# @param    $(src)          Source (parent) object.
# @param    $(trg)          Target (child) object.
define def_inherit_one_overriding_now_l
ifdef $(src)_$(prop)
 ifndef $(trg)_$(prop)
  $(trg)_$(prop) := $($(src)_$(prop))
 endif
endif
endef

## @copydoc def_inherit_one_overriding_now_l
define def_inherit_one_overriding_now_r
ifdef $(src)_$(prop)
 ifndef $(trg)_$(prop)
  $(trg)_$(prop) := $($(src)_$(prop))
 endif
endif
endef

## Inherit one template property in a non-accumulative manner, deferred expansion.
# @param    $(prop)         Property name
# @param    $(src)          Source
# @param    $(trg)          Target
# @remark This define relies on double evaluation
define def_inherit_one_overriding_deferred
ifdef $(src)_$(prop)
 ifndef $(trg)_$(prop)
  $(trg)_$(prop) = $$($(src)_$(prop))
 endif
endif
endef

## @copydoc def_inherit_one_overriding_deferred
define def_inherit_one_overriding_deferred_l
ifdef $(src)_$(prop)
 ifndef $(trg)_$(prop)
  $(trg)_$(prop) = $$($(src)_$(prop))
 endif
endif
endef

## @copydoc def_inherit_one_overriding_deferred
define def_inherit_one_overriding_deferred_r
ifdef $(src)_$(prop)
 ifndef $(trg)_$(prop)
  $(trg)_$(prop) = $$($(src)_$(prop))
 endif
endif
endef


# EXPAND_BY = prepending

## Inherit one template property in a prepending manner.
# @param    $(prop)         Property name
# @param    $(src)          Source (parent) object.
# @param    $(trg)          Target (child) object.
define def_inherit_one_prepending_now_l
ifdef $(src)_$(prop)
 $(trg)_$(prop) := $($(src)_$(prop)) $($(trg)_$(prop))
endif
endef

## @copydoc def_inherit_one_prepending_now_l
define def_inherit_one_prepending_now_r
ifdef $(src)_$(prop)
 $(trg)_$(prop) := $($(trg)_$(prop)) $($(src)_$(prop))
endif
endef

## Inherit one template property in a non-accumulative manner, deferred expansion.
# @param    $(prop)         Property name
# @param    $(src)          Source
# @param    $(trg)          Target
# @remark This define relies on double evaluation
define def_inherit_one_prepending_deferred
ifdef $(src)_$(prop)
 ifndef $(trg)_$(prop)
  $(trg)_$(prop) = $$($(src)_$(prop))
 endif
endif
endef

## Inherit one template property in a prepending manner, deferred expansion.
# @param    $(prop)         Property name
# @param    $(src)          Source (parent) object.
# @param    $(trg)          Target (child) object.
define def_inherit_one_prepending_deferred_l
ifdef $(src)_$(prop)
 ifeq ($$(flavor $(trg)_$(prop)),simple)
  $$(evalcall2 def_simple_2_recursive,$(trg)_$(prop))
 endif
 $(trg)_$(prop) <= $$($(src)_$(prop))
endif
endef

## @copydoc def_inherit_one_prepending_deferred_l
define def_inherit_one_prepending_deferred_r
ifdef $(src)_$(prop)
 ifeq ($$(flavor $(trg)_$(prop)),simple)
  $$(evalcall2 def_simple_2_recursive,$(trg)_$(prop))
 endif
 $(trg)_$(prop) += $$($(src)_$(prop))
endif
endef


# EXPAND_BY = appending

## Inherit one template property in an appending manner.
# @param    $(prop)         Property name
# @param    $(src)          Source (parent) object.
# @param    $(trg)          Target (child) object.
define def_inherit_one_appending_now_l
ifdef $(src)_$(prop)
 $(trg)_$(prop) := $($(trg)_$(prop)) $($(src)_$(prop))
endif
endef

## @copydoc def_inherit_one_appending_now_l
define def_inherit_one_appending_now_r
ifdef $(src)_$(prop)
 $(trg)_$(prop) := $($(src)_$(prop)) $($(trg)_$(prop))
endif
endef

## Inherit one template property in a non-accumulative manner, deferred expansion.
# @param    $(prop)         Property name
# @param    $(src)          Source
# @param    $(trg)          Target
# @remark This define relies on double evaluation
define def_inherit_one_appending_deferred
ifdef $(src)_$(prop)
 ifndef $(trg)_$(prop)
  $(trg)_$(prop) = $$($(src)_$(prop))
 endif
endif
endef

## Inherit one template property in an appending manner, deferred expansion.
# @param    $(prop)         Property name
# @param    $(src)          Source (parent) object.
# @param    $(trg)          Target (child) object.
define def_inherit_one_appending_deferred_l
ifdef $(src)_$(prop)
 ifeq ($$(flavor $(trg)_$(prop)),simple)
  $$(evalcall2 def_simple_2_recursive,$(trg)_$(prop))
 endif
 $(trg)_$(prop) += $$($(src)_$(prop))
endif
endef

## @copydoc def_inherit_one_appending_deferred_l
define def_inherit_one_appending_deferred_r
ifdef $(src)_$(prop)
 ifeq ($$(flavor $(trg)_$(prop)),simple)
  $$(evalcall2 def_simple_2_recursive,$(trg)_$(prop))
 endif
 $(trg)_$(prop) <= $$($(src)_$(prop))
endif
endef


## combines the specified properties $(1) with the $(_KEYWORDS) list.
_INHERIT_JOIN_KEYWORDS = $(1)  $(foreach keyword,$(_KEYWORDS), $(addsuffix .$(keyword), $(1)))


## Generic inheritance for use with targets templates and tools.
# @param    trg                   Object to consider for inheriting.
# @param    src_prefix            What to prefix the value found in EXTENDS with to get the object.
# @param    load_function         Load function for stuff that needs
# @param    properties            List of the properties with straight expansion.
# @param    properties_now_l      List of the properties with immediate expansion, accumulating on the left side.
# @param    properties_now_r      List of the properties with immediate expansion, accumulating on the right side.
# @param    properties_deferred   List of the properties with deferred expansion (e.g. function), non-accumulative .
# @param    properties_deferred_l List of the properties with deferred expansion (e.g. function), accumulating on the left side.
# @param    properties_deferred_r List of the properties with deferred expansion (e.g. function), accumulating on the right side.
define def_inherit

# Load it - loading is a mess, fix.
ifneq ($(load_function),)
 local loading := $(patsubst $(src_prefix)%,%,$(trg))
 $(evalvalctx $(load_function))
endif

local src := $(strip $($(trg)_EXTENDS))
ifneq ($(src),)
 ifndef $(trg)_EXTENDS_STATUS_
  $(trg)_EXTENDS_STATUS_ := 0

  # Load the source.
  ifneq ($(load_function),)
   local loading := $(src)
   $(evalvalctx $(load_function))
  endif

  # less typing.
  local src := $(src_prefix)$(src)

  # Recursivly process the parent (src) if it's inherting from somebody too.
  ifdef $(src)_EXTENDS
   ifneq ($($(src)_EXTENDS_STATUS_),42)
    # 'foreach' will create 'trg' in a new variable context hiding
    # out current variable. 'src' OTOH will be overwritten.
    $(foreach trg, $(src), $(evalval def_inherit))
    local src := $(src_prefix)$(strip $($(trg)_EXTENDS))
   endif
  endif

  # Get & check EXTENDS_BY.
  local by = $(strip $($(trg)_EXTENDS_BY))
  ifeq ($(by),)
   local by = overriding
  else ifn1of ($(by), overriding appending prepending)
   $(error kBuild: Invalid EXTENDS_BY value '$(by)' on '$(trg)'!)
  endif

  # Inherit the properties.
  $(foreach prop, $(call _INHERIT_JOIN_KEYWORDS,$(properties)),            $(eval $(def_inherit_one)))
  $(foreach prop, $(call _INHERIT_JOIN_KEYWORDS,$(properties_now_l)),      $(eval $(def_inherit_one_$(by)_now_l)))
  $(foreach prop, $(call _INHERIT_JOIN_KEYWORDS,$(properties_now_r)),      $(eval $(def_inherit_one_$(by)_now_r)))
  $(foreach prop, $(call _INHERIT_JOIN_KEYWORDS,$(properties_deferred)),   $(eval $(def_inherit_one_$(by)_deferred)))
  $(foreach prop, $(call _INHERIT_JOIN_KEYWORDS,$(properties_deferred_l)), $(eval $(def_inherit_one_$(by)_deferred_l)))
  $(foreach prop, $(call _INHERIT_JOIN_KEYWORDS,$(properties_deferred_r)), $(eval $(def_inherit_one_$(by)_deferred_r)))

  # Mark the target as done.
  $(trg)_EXTENDS_STATUS_ := 42
 else
  # Check for inheritance loops.
  ifneq ($($(trg)_EXTENDS_STATUS_),42)
   $(error kBuild: Target inheritance loop! target=$(trg) $(trg)_EXTENDS_STATUS_=$($(trg)_EXTENDS_STATUS_))
  endif
 endif
endif

# Keyword inheritance.
$(foreach prefix_keyword, $(join $(_KEYWORDS_PREFIX), $(addprefix :,$(_KEYWORDS_EXTENDS))), $(evalval def_inherit_keyword))

endef # def_inherit


#
# Load global units before doing any inheriting so they can add new properties.
#
# This only applies to the guys listed in the global USES since there is
# no reliable way to deal with things on a target level without first
# applying templates. So, to avoid having USES mess up all targets,
# we'll make the global and per-target USES property work differently:
#     The global USES does not apply to targets, just globally.
#

## Unit load function.
# @param loading    The unit name
define def_unit_load_function
ifndef UNIT_$(loading)
 UNIT_$(loading)_KMK_FILE := $(firstword $(foreach path, $(KBUILD_UNIT_PATHS) $(KBUILD_PATH)/units $(KBUILD_DEFAULT_PATHS), $(wildcard $(path)/$(loading).kmk)))
 ifeq ($(UNIT_$(loading)_KMK_FILE),)
  $(error kBuild: Cannot find include file for the unit '$(loading)'! Searched: $(KBUILD_UNIT_PATHS) $(KBUILD_PATH)/units $(KBUILD_DEFAULT_PATHS))
 endif
 include $(UNIT_$(loading)_KMK_FILE)
 ifndef UNIT_$(loading)
  $(warning kBuild: UNIT_$(loading) was not defined by $(UNIT_$(loading)_KMK_FILE)!)
 endif
endif
endef # def_unit_load_function

$(foreach loading, \
	$(USES.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)) \
	$(USES.$(KBUILD_TARGET_CPU)) \
	$(USES.$(KBUILD_TARGET_ARCH)) \
	$(USES.$(KBUILD_TARGET)) \
	$(USES.$(KBUILD_HOST).$(KBUILD_HOST_ARCH)) \
	$(USES.$(KBUILD_HOST_CPU)) \
	$(USES.$(KBUILD_HOST_ARCH)) \
	$(USES.$(KBUILD_TARGET)) \
	$(USES.$(KBUILD_TYPE)) \
	$(USES),$(evalval def_unit_load_function))


#
# Determin all the templates that is being used and make
# sure they are present before we try collect keywords.
#
_TEMPLATES := $(TEMPLATE)
define def_templates
ifdef $(target)_TEMPLATE
 ifneq ("$($(target)_TEMPLATE)","$(strip $($(target)_TEMPLATE))")
  $$(error kBuild: The template name of target '$(target)' contains tabs ($($(target)_TEMPLATE))). Please remove them)
 endif
 _TEMPLATES += $($(target)_TEMPLATE)
endif
endef # def_templates
$(foreach target, $(_ALL_TARGETS), $(eval $(def_templates)))
_TEMPLATES := $(sort $(_TEMPLATES))

## Template load function.
# @param loading    The template name. This is prefixed.
define def_templates_load_function
ifndef TEMPLATE_$(loading)
 TEMPLATE_$(loading)_KMK_FILE := $(firstword $(foreach path, $(KBUILD_TEMPLATE_PATHS) $(KBUILD_PATH)/templates $(KBUILD_DEFAULT_PATHS), $(wildcard $(path)/$(loading).kmk)))
 ifeq ($(TEMPLATE_$(loading)_KMK_FILE),)
  $(error kBuild: Cannot find include file for the template '$(loading)'! Searched: $(KBUILD_TEMPLATE_PATHS) $(KBUILD_PATH)/templates $(KBUILD_DEFAULT_PATHS))
 endif
 include $(TEMPLATE_$(loading)_KMK_FILE)
 ifndef TEMPLATE_$(loading)
  $(warning kBuild: TEMPLATE_$(loading) was not defined by $(TEMPLATE_$(loading)_KMK_FILE)!)
 endif
endif
endef # def_templates_load_function
$(foreach loading, $(_TEMPLATES), $(evalval def_templates_load_function))


#
# Determin the keywords required for correct inherting and setup keyword inheritance.
#
# This means walking all the lists of immediate template and targets and
# pick up all the BLD_T* keywords. Since templates that are referenced
# indirectly in the inheritance hierarchy, the result from this exercise
# might not be 100% accurate... :-/
#
_BLD_TYPES   := $(KBUILD_TYPE)
_BLD_TARGETS := $(KBUILD_TARGET) $(KBUILD_HOSTS)
_BLD_ARCHES  := $(KBUILD_TARGET_ARCH) $(KBUILD_HOST_ARCH)
_BLD_CPUS    := $(KBUILD_TARGET_CPU) $(KBUILD_HOST_CPU)

define def_collect_bld_xyz
ifdef $(src)_BLD_TYPE
 ifn1of ($($(src)_BLD_TYPE), $(KBUILD_BLD_TYPES))
  $(error kBuild: $(src)_BLD_TYPE=$($(src)_BLD_TYPE) not in KBUILD_BLD_TYPES={$(KBUILD_BLD_TYPES)}!)
 endif
 _BLD_TYPES += $($(src)_BLD_TYPE)
endif
ifdef $(src)_BLD_TRG
 ifn1of ($($(src)_BLD_TRG), $(KBUILD_OSES))
  $(error kBuild: $(src)_BLD_TRG=$($(src)_BLD_TRG) not in KBUILD_OSES={$(KBUILD_OSES)}!)
 endif
 _BLD_TARGETS += $($(src)_BLD_TRG)
endif
ifdef $(src)_BLD_TRG_ARCH
 ifn1of ($($(src)_BLD_TRG_ARCH), $(KBUILD_ARCHES))
  $(error kBuild: $(src)_BLD_TRG_ARCH=$($(src)_BLD_TRG_ARCH) not in KBUILD_ARCHES={$(KBUILD_ARCHES)}!)
 endif
 _BLD_ARCHES += $($(src)_BLD_TRG_ARCH)
endif
ifdef $(src)_BLD_TRG_CPU
 if1of ($($(src)_BLD_CPU), $(KBUILD_ARCHES) $(KBUILD_OSES) $(KBUILD_BLD_TYPES))
  $(error kBuild: $(src)_BLD_TRG_CPU=$($(src)_BLD_TRG_CPU) found in KBUILD_ARCHES, KBUILD_OSES or KBUILD_BLD_TYPES!)
 endif
 _BLD_CPUS += $($(src)_BLD_TRG_CPU)
endif
endef # def_collect_bld_xyz
$(foreach src, $(addprefix TEMPLATE_, $(_TEMPLATES)) $(_ALL_TARGETS) \
	,$(evalval def_collect_bld_xyz))

# Drop duplicate values.
# WARNING! These list might not include keywords only involved in inheritance.
_BLD_TYPES   := $(sort $(_BLD_TYPES))
_BLD_TARGETS := $(sort $(_BLD_TARGETS))
_BLD_ARCHES  := $(sort $(_BLD_ARCHES))
_BLD_CPUS    := $(sort $(_BLD_CPUS))

## Look for keywords which extends others and order them.
# @param    keyword
# @param    prefix
# @param    valid
define def_keyword_ordering
# Check for EXTENDS, fix and validate it if found.
local src := $(strip $($(prefix)_$(keyword)_EXTENDS))
ifneq ($(src),)
 ifndef $(prefix)_$(keyword)_EXTENDS_STATUS_
  ifn1of ($(src), $(valid))
   $(error kBuild: $(keyword) tries to extend unknown keyword '$(src)'! (known = $(valid)))
  endif

  # Recursivly process the parent (src).
  ifneq ($($(prefix)_$(src)_EXTENDS_STATUS_),42)
   $(prefix)_$(keyword)_EXTENDS_STATUS_ := 0
   # 'foreach' will create 'keyword' in a new variable context hiding
   # out current variable. 'src' OTOH will be overwritten.
   $(foreach keyword, $(src), $(evalval def_keyword_ordering))
   local src := $(strip $($(prefix)_$(keyword)_EXTENDS))
  endif

  # Check and strip EXTENDS_BY.
  local by = $(strip $($(prefix)_$(keyword)_EXTENDS_BY))
  ifeq ($(by),)
   local by = overriding
  else ifn1of ($(by), overriding appending prepending)
   $(error kBuild: Invalid EXTENDS_BY value '$(by)' on '$(keyword)'!)
  endif

  # Update the attributes with stripped
  $(prefix)_$(keyword)_EXTENDS_BY := $(by)
  $(prefix)_$(keyword)_EXTENDS := $(src)

  # Add it to the list and mark it as done.
  _KEYWORDS_EXTENDS += $(keyword)
  _KEYWORDS_PREFIX  += $(prefix)
  $(prefix)_$(keyword)_EXTENDS_STATUS_ := 42
 else
  # Check for inheritance loops.
  ifneq ($($(trg)_EXTENDS_STATUS_),42)
   $(error kBuild: Keyword inheritance loop! keyword=$(keyword) $(prefix)_$(keyword)_EXTENDS_STATUS_=$($(prefix)_$(keyword)_EXTENDS_STATUS_))
  endif
 endif
else
 # Add it to the ordered list and mark it as done.
 _KEYWORDS_ORDERED += $(keyword)
 $(prefix)_$(src)_EXTENDS_STATUS_ := 42
endif
endef # def_keyword_ordering
$(eval-opt-var def_keyword_ordering)

# Look for keywords which extends others and their parents, and from this
# construct two lists.
_KEYWORDS_ORDERED :=
_KEYWORDS_EXTENDS :=
_KEYWORDS_PREFIX  :=

prefix := BLD_TYPE
valid := $(KBUILD_BLD_TYPES)
$(foreach keyword, $(_BLD_TYPES)  , $(evalval def_keyword_ordering))

prefix := BLD_TRG
valid := $(KBUILD_OSES)
$(foreach keyword, $(_BLD_TARGETS), $(evalval def_keyword_ordering))

prefix := BLD_ARCH
valid := $(KBUILD_ARCHES)
$(foreach keyword, $(_BLD_ARCHES) , $(evalval def_keyword_ordering))

prefix := BLD_CPU
valid := $(KBUILD_CPUS)
$(foreach keyword, $(_BLD_CPUS)   , $(evalval def_keyword_ordering))

## @todo Inherit bld_trg.bld_arch for too?

# Construct all the possible keywords.
_KEYWORDS := $(_KEYWORDS_ORDERED) $(_KEYWORDS_EXTENDS) \
	$(foreach bld_trg,$(_BLD_TARGETS),$(addprefix $(bld_trg).,$(_BLD_ARCHES)))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done keywords)
endif


#
# Target inheritance.
#
# This has to be done on a per target list basis as to avoid adding
# incorrect properties that will wast memory, time, and may confuse
# later strictness checks. This also has to be done *before* templates
# are applied to the targets. Since we're doing that part rather
# early on, the target inheritance feature is a bit restricted at
# the moment. However, this will be addressed in a little(?) while.
#

src_prefix :=
load_function :=
properties_deferred_l :=
properties_deferred_r :=

# Fetches.
properties          := $(PROPS_FETCHES_SINGLE)
properties_now_l    := $(PROPS_FETCHES_ACCUMULATE_L)
properties_now_r    := $(PROPS_FETCHES_ACCUMULATE_R)
properties_deferred := $(PROPS_FETCHES_DEFERRED)
$(foreach trg, $(_ALL_FETCHES),$(evalval def_inherit))

## Patches. - not implemented yet.
#properties          := $(PROPS_PATCHES_SINGLE)
#properties_now_l    := $(PROPS_PATCHES_ACCUMULATE_L)
#properties_now_r    := $(PROPS_PATCHES_ACCUMULATE_R)
#properties_deferred := $(PROPS_PATCHES_DEFERRED)
#$(foreach trg, $(_ALL_PATCHES),$(evalval def_inherit))

# Programs and build programs.
properties          := $(PROPS_PROGRAMS_SINGLE)
properties_now_l    := $(PROPS_PROGRAMS_ACCUMULATE_L)
properties_now_r    := $(PROPS_PROGRAMS_ACCUMULATE_R)
properties_deferred := $(PROPS_PROGRAMS_DEFERRED)
$(foreach trg, $(_ALL_BLDPROGS) $(_ALL_PROGRAMS),$(evalval def_inherit))

# Libraries and import libraries.
properties          := $(PROPS_LIBRARIES_SINGLE)
properties_now_l    := $(PROPS_LIBRARIES_ACCUMULATE_L)
properties_now_r    := $(PROPS_LIBRARIES_ACCUMULATE_R)
properties_deferred := $(PROPS_LIBRARIES_DEFERRED)
if1of ($(KBUILD_TARGET), nt os2 win)
 $(foreach trg, $(_ALL_LIBRARIES) $(_ALL_IMPORT_LIBS),$(evalval def_inherit))
else
 $(foreach trg, $(_ALL_LIBRARIES),$(evalval def_inherit))
endif

# DLLs.
properties          := $(PROPS_DLLS_SINGLE)
properties_now_l    := $(PROPS_DLLS_ACCUMULATE_L)
properties_now_r    := $(PROPS_DLLS_ACCUMULATE_R)
properties_deferred := $(PROPS_DLLS_DEFERRED)
if1of ($(KBUILD_TARGET), nt os2 win)
 $(foreach trg, $(_ALL_DLLS),$(evalval def_inherit))
else
 $(foreach trg, $(_ALL_DLLS) $(_ALL_IMPORT_LIBS),$(evalval def_inherit))
endif

# System modules.
properties          := $(PROPS_SYSMODS_SINGLE)
properties_now_l    := $(PROPS_SYSMODS_ACCUMULATE_L)
properties_now_r    := $(PROPS_SYSMODS_ACCUMULATE_R)
properties_deferred := $(PROPS_SYSMODS_DEFERRED)
$(foreach trg, $(_ALL_SYSMODS),$(evalval def_inherit))

# Misc binaries.
properties          := $(PROPS_MISCBINS_SINGLE)
properties_now_l    := $(PROPS_MISCBINS_ACCUMULATE_L)
properties_now_r    := $(PROPS_MISCBINS_ACCUMULATE_R)
properties_deferred := $(PROPS_MISCBINS_DEFERRED)
$(foreach trg, $(_ALL_MISCBINS),$(evalval def_inherit))

# Installs.
properties          := $(PROPS_INSTALLS_SINGLE)
properties_now_l    := $(PROPS_INSTALLS_ACCUMULATE_L)
properties_now_r    := $(PROPS_INSTALLS_ACCUMULATE_R)
properties_deferred := $(PROPS_INSTALLS_DEFERRED)
$(foreach trg, $(_ALL_INSTALLS),$(evalval def_inherit))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done target inheritance)
endif


#
# Template Inheritance.
#
# This is much the same as with target inheritance, except we cannot
# restrict the properties involved since we haven't got a clue which
# target platforms/archs are using them. But, we can drop the instance
# expansion we're doing for targets since there won't be any more
# changes to either the source nor the target templates beyond this
# exercise.
#

src_prefix := TEMPLATE_
load_function := def_templates_load_function
properties :=
properties_now_l :=
properties_now_r :=
properties_deferred   := $(PROPS_SINGLE) $(PROPS_DEFERRED)
properties_deferred_l := $(PROPS_ACCUMULATE_L)
properties_deferred_r := $(PROPS_ACCUMULATE_R)
$(foreach trg, $(addprefix TEMPLATE_,$(_TEMPLATES)),$(evalval def_inherit))

# done inheriting.
src_prefix :=
load_function :=
properties :=
properties_now_l :=
properties_now_r :=
properties_deferred :=
properties_deferred_l :=
properties_deferred_r :=

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done template inheritance)
endif




#
# Template/Target Expansion.
#
# Extend all targets with the values from the template. Doing this up front
# allows more generic code and less mess down in the pass 2 target handling.
# However it does eat a good deal of memory.
#

define def_inherit_template_workaround_target
local _tmpl         := $(firstword $($(target)_TEMPLATE) $(TEMPLATE))
local _bld_type     := $(firstword $($(target)_BLD_TYPE)     $(TEMPLATE_$(_tmpl)_BLD_TYPE)     $(KBUILD_TYPE))
local _bld_trg      := $(firstword $($(target)_BLD_TRG)      $(TEMPLATE_$(_tmpl)_BLD_TRG)      $(KBUILD_TARGET))
local _bld_trg_arch := $(firstword $($(target)_BLD_TRG_ARCH) $(TEMPLATE_$(_tmpl)_BLD_TRG_ARCH) $(KBUILD_TARGET_ARCH))
local _bld_trg_cpu  := $(firstword $($(target)_BLD_TRG_CPU)  $(TEMPLATE_$(_tmpl)_BLD_TRG_CPU)  $(KBUILD_TARGET_CPU))
$(kb-exp-tmpl 1,$(target),$(_bld_trg),$(_bld_trg_arch),$(_bld_trg_cpu),$(_bld_type))
endef # def_inherit_template_workaround_target
#$(kb-exp-tmpl 1,$(_ALL_TARGET_TARGETS),$(KBUILD_TARGET),$(KBUILD_TARGET_ARCH),$(KBUILD_TARGET_CPU),$(KBUILD_TYPE))
$(foreach target,$(_ALL_TARGET_TARGETS),$(evalval def_inherit_template_workaround_target))

define def_inherit_template_workaround_host
local _tmpl         := $(firstword $($(target)_TEMPLATE) $(TEMPLATE))
local _bld_type     := $(firstword $($(target)_BLD_TYPE)     $(TEMPLATE_$(_tmpl)_BLD_TYPE)     $(KBUILD_TYPE))
local _bld_trg      := $(firstword $($(target)_BLD_TRG)      $(TEMPLATE_$(_tmpl)_BLD_TRG)      $(KBUILD_HOST))
local _bld_trg_arch := $(firstword $($(target)_BLD_TRG_ARCH) $(TEMPLATE_$(_tmpl)_BLD_TRG_ARCH) $(KBUILD_HOST_ARCH))
local _bld_trg_cpu  := $(firstword $($(target)_BLD_TRG_CPU)  $(TEMPLATE_$(_tmpl)_BLD_TRG_CPU)  $(KBUILD_HOST_CPU))
$(kb-exp-tmpl 1,$(target),$(_bld_trg),$(_bld_trg_arch),$(_bld_trg_cpu),$(_bld_type))
endef # def_inherit_template_workaround_target
#$(kb-exp-tmpl 1,$(_ALL_HOST_TARGETS),$(KBUILD_HOST),$(KBUILD_HOST_ARCH),$(KBUILD_HOST_CPU),$(KBUILD_TYPE))
$(foreach target,$(_ALL_HOST_TARGETS),$(evalval def_inherit_template_workaround_host))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done template/target expansion)
endif


#
# Include tools, sdks and units.
#
# The first part of this exercise is to figure out which TOOLS and SDKS
# that should be included.
#
_TOOLS := $(TOOL.$(KBUILD_TARGET))   $(TOOL.$(KBUILD_TARGET_ARCH))   $(TOOL.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)) \
          $(TOOL.$(KBUILD_HOST)) $(TOOL.$(KBUILD_HOST_ARCH)) $(TOOL.$(KBUILD_HOST).$(KBUILD_HOST_ARCH)) \
	  $(TOOL)
_SDKS  := $(SDKS.$(KBUILD_TARGET))   $(SDKS.$(KBUILD_TARGET_ARCH))   $(SDKS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)) \
          $(SDKS.$(KBUILD_HOST)) $(SDKS.$(KBUILD_HOST_ARCH)) $(SDKS.$(KBUILD_HOST).$(KBUILD_HOST_ARCH)) \
	  $(SDKS.$(KBUILD_TYPE)) \
	  $(SDKS)
_USES  := $(USES.$(KBUILD_TARGET))   $(USES.$(KBUILD_TARGET_ARCH))   $(USES.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)) \
          $(USES.$(KBUILD_HOST)) $(USES.$(KBUILD_HOST_ARCH)) $(USES.$(KBUILD_HOST).$(KBUILD_HOST_ARCH)) \
	  $(USES.$(KBUILD_TYPE)) \
	  $(USES)
define def_tools_sdks_target_source
$(eval _TOOLS += $(foreach prop, $(PROPS_TOOLS), \
	$($(source)_$(prop).$(_bld_trg)) \
	$($(target)_$(source)_$(prop).$(_bld_trg)) \
	$($(source)_$(prop).$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_$(source)_$(prop).$(_bld_trg).$(_bld_trg_arch)) \
	$($(source)_$(prop).$(_bld_trg_arch)) \
	$($(target)_$(source)_$(prop).$(_bld_trg_arch)) \
	$($(source)_$(prop)) \
	$($(target)_$(source)_$(prop))))
$(eval _SDKS += \
	$($(source)_SDKS.$(_bld_trg)) \
	$($(target)_$(source)_SDKS.$(_bld_trg)) \
	$($(source)_SDKS.$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_$(source)_SDKS.$(_bld_trg).$(_bld_trg_arch)) \
	$($(source)_SDKS.$(_bld_trg_arch)) \
	$($(target)_$(source)_SDKS.$(_bld_trg_arch)) \
	$($(source)_SDKS.$(KBUILD_TYPE)) \
	$($(target)_$(source)_SDKS.$(KBUILD_TYPE)) \
	$($(source)_SDKS) \
	$($(target)_$(source)_SDKS))
$(eval _USES += \
	$($(source)_USES.$(_bld_trg)) \
	$($(target)_$(source)_USES.$(_bld_trg)) \
	$($(source)_USES.$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_$(source)_USES.$(_bld_trg).$(_bld_trg_arch)) \
	$($(source)_USES.$(_bld_trg_arch)) \
	$($(target)_$(source)_USES.$(_bld_trg_arch)) \
	$($(source)_USES.$(KBUILD_TYPE)) \
	$($(target)_$(source)_USES.$(KBUILD_TYPE)) \
	$($(source)_USES) \
	$($(target)_$(source)_USES))
endef # def_tools_sdks_target_source
$(eval-opt-var def_tools_sdks_target_source)

define def_tools_sdks_target
local _bld_type := $(firstword $($(target)_BLD_TYPE) $(KBUILD_TYPE))
local _bld_trg := $(firstword $($(target)_BLD_TRG) $(bld_trg))
local _bld_trg_arch := $(firstword $($(target)_BLD_TRG_ARCH) $(bld_trg_arch))
local _bld_trg_cpu := $(firstword $($(target)_BLD_TRG_CPU) $(bld_trg_cpu))

$(eval _TOOLS += $(foreach prop, $(PROPS_TOOLS), \
	$($(target)_$(prop).$(_bld_trg)) \
	$($(target)_$(prop).$(_bld_trg_arch)) \
	$($(target)_$(prop).$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_$(prop))))
$(eval _SDKS += \
	$($(target)_SDKS.$(_bld_trg)) \
	$($(target)_SDKS.$(_bld_trg_arch)) \
	$($(target)_SDKS.$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_SDKS))
$(eval _USES += \
	$($(target)_USES.$(_bld_trg)) \
	$($(target)_USES.$(_bld_trg_arch)) \
	$($(target)_USES.$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_USES))
$(foreach source, \
	$($(target)_SOURCES.$(_bld_trg)) \
	$($(target)_SOURCES.$(_bld_trg_arch)) \
	$($(target)_SOURCES.$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_SOURCES.$(_bld_trg_cpu)) \
	$($(target)_SOURCES.$(_bld_type)) \
	$($(target)_SOURCES) \
	, $(evalval def_tools_sdks_target_source))
endef # def_tools_sdks_target
$(eval-opt-var def_tools_sdks_target)

define def_tools_srcname_target
local _bld_type := $(firstword $($(target)_BLD_TYPE) $(KBUILD_TYPE))
local _bld_trg := $(firstword $($(target)_BLD_TRG) $(bld_trg))
local _bld_trg_arch := $(firstword $($(target)_BLD_TRG_ARCH) $(bld_trg_arch))
local _bld_trg_cpu := $(firstword $($(target)_BLD_TRG_CPU) $(bld_trg_cpu))

$(foreach source, $(notdir\
	$($(target)_SOURCES.$(_bld_trg)) \
	$($(target)_SOURCES.$(_bld_trg_arch)) \
	$($(target)_SOURCES.$(_bld_trg).$(_bld_trg_arch)) \
	$($(target)_SOURCES.$(_bld_trg_cpu)) \
	$($(target)_SOURCES.$(_bld_type)) \
	$($(target)_SOURCES) \
	), $(evalval def_tools_sdks_target_source))
endef # def_tools_srcname_target
$(eval-opt-var def_tools_srcname_target)

bld_trg := $(KBUILD_TARGET)
bld_trg_arch := $(KBUILD_TARGET_ARCH)
bld_trg_cpu := $(KBUILD_TARGET_CPU)
$(foreach target, $(_ALL_TARGET_TARGETS), $(evalval def_tools_sdks_target))
$(foreach target, $(_ALL_SRCNAME_TARGETS), $(evalval def_tools_srcname_target))

bld_trg := $(KBUILD_HOST)
bld_trg_arch := $(KBUILD_HOST_ARCH)
bld_trg_cpu := $(KBUILD_HOST_CPU)
$(foreach target, $(_ALL_HOST_TARGETS), $(evalval def_tools_sdks_target))

_TOOLS := $(sort $(_TOOLS))
_SDKS := $(sort $(_SDKS))

## Tool load function.
# @param loading    The tool name
define def_tools_load_function
ifndef TOOL_$(loading)
 TOOL_$(loading)_KMK_FILE := $(firstword $(foreach path, $(KBUILD_TOOL_PATHS) $(KBUILD_PATH)/tools $(KBUILD_DEFAULT_PATHS), $(wildcard $(path)/$(loading).kmk)))
 ifeq ($(TOOL_$(loading)_KMK_FILE),)
  $(error kBuild: Cannot find include file for the tool '$(loading)'! Searched: $(KBUILD_TOOL_PATHS) $(KBUILD_PATH)/tools $(KBUILD_DEFAULT_PATHS))
 endif
 include $(TOOL_$(loading)_KMK_FILE)
 ifndef TOOL_$(loading)
  $(warning kBuild: TOOL_$(loading) was not defined by $(TOOL_$(loading)_KMK_FILE)!)
 endif
endif
endef # def_tools_include

## SDK load function.
# @param loading    The tool name
define def_sdk_load_function
ifndef SDK_$(loading)
 SDK_$(loading)_KMK_FILE := $(firstword $(foreach path, $(KBUILD_SDK_PATHS) $(KBUILD_PATH)/sdks $(KBUILD_DEFAULT_PATHS), $(wildcard $(path)/$(loading).kmk)))
 ifeq ($(SDK_$(loading)_KMK_FILE),)
  $(error kBuild: Cannot find include file for the SDK '$(loading)'! Searched: $(KBUILD_SDK_PATHS) $(KBUILD_PATH)/sdks $(KBUILD_DEFAULT_PATHS))
 endif
 include $(SDK_$(loading)_KMK_FILE)
 ifndef SDK_$(loading)
  $(warning kBuild: SDK_$(loading) was not defined by $(SDK_$(loading)_KMK_FILE)!)
 endif
endif
endef # def_sdk_load_function


properties :=
properties_now_l :=
properties_now_r :=
properties_deferred   := $(PROPS_SINGLE) $(PROPS_DEFERRED)
properties_deferred_l := $(PROPS_ACCUMULATE_L)
properties_deferred_r := $(PROPS_ACCUMULATE_R)

src_prefix := SDK_
load_function := def_sdk_load_function
$(foreach trg, $(addprefix SDK_,$(_SDKS)), $(evalval def_inherit))

properties_deferred   := $(PROPS_SINGLE) $(PROPS_DEFERRED) $(PROPS_TOOLS_ONLY)
src_prefix := TOOL_
load_function := def_tools_load_function
$(foreach trg, $(addprefix TOOL_,$(_TOOLS)), $(evalval def_inherit))

# done inheriting.
src_prefix :=
load_function :=
properties :=
properties_now_l :=
properties_now_r :=
properties_deferred :=
properties_deferred_l :=
properties_deferred_r :=

# No inheriting for the uses, they're just global 'code'.
$(foreach loading, $(_USES), $(evalval def_unit_load_function))


ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done tools + sdks + units)
endif



#
#
# Target lists - Pass 1
#
#       This pass is for defining variables that might be referenced in
#       properties of other targets.
#
#

# Don't do anything for fetch targets (yet).

##
# Link prolog for Pass 1.
#
# @param    $(target)           Normalized target name.
# @param    $(EXT)              EXE,DLL,SYS,LIB.
# @param    $(EXTPRE)           HOST or nothing.
# @param    $(definst)          The default _INST value.
# @param    $(tool_prefix)      LD or AR.
# @param    $(bld_trg_base_var) TARGET or PLATFORM.
define def_pass1_link_common

local bld_type    := $(firstword $($(target)_BLD_TYPE)     $(KBUILD_TYPE))
local bld_trg     := $(firstword $($(target)_BLD_TRG)      $(BUILD_$(bld_trg_base_var)))
local bld_trg_arch:= $(firstword $($(target)_BLD_TRG_ARCH) $(BUILD_$(bld_trg_base_var)_ARCH))
local bld_trg_cpu := $(firstword $($(target)_BLD_TRG_CPU)  $(BUILD_$(bld_trg_base_var)_CPU))

local tool        := $(call _TARGET_TOOL,$(target),$(tool_prefix))
local name        := $(firstword\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg))\
	$($(target)_NAME.$(bld_type))\
	$($(target)_NAME)\
	$(target))
local outbase     := $(call TARGET_BASE,$(name),$(target))
$(target)_0_OUTDIR:= $(patsubst %/,%,$(dir $(outbase)))
PATH_$(target)    := $($(target)_0_OUTDIR)
## @todo fix the fun at the last line (AR != LIB => mess).
local suff := $(firstword \
	$($(target)_$(EXT)SUFF.$(bld_trg).$(bld_trg_arch))\
	$($(target)_$(EXT)SUFF.$(bld_trg))\
	$($(target)_$(EXT)SUFF)\
	$(TOOL_$(tool)_$(tool_prefix)$(EXT)SUFF.$(bld_trg).$(bld_trg_arch))\
	$(TOOL_$(tool)_$(tool_prefix)$(EXT)SUFF.$(bld_trg))\
	$(TOOL_$(tool)_$(tool_prefix)$(EXT)SUFF)\
	$(if $(eq $(tool_prefix),AR),$(SUFF_LIB),$($(EXTPRE)SUFF_$(EXT))) )
local out := $(outbase)$(suff)

# TARGET_*
TARGET_$(target)   := $(out)
$(target)_1_TARGET := $(out)

# INSTARGET_*
ifeq ($(strip $($(target)_NOINST) $($(target)_NOINST.$(bld_trg)) $($(target)_NOINST.$(bld_trg).$(bld_trg_arch)) $($(target)_NOINST.$(bld_trg).$(bld_trg_arch).$(bld_type))  $($(target)_NOINST.$(bld_trg_arch)) $($(target)_NOINST.$(bld_trg_cpu)) $($(target)_NOINST.$(bld_trg_type))),)
 ifneq ($(strip $($(target)_INST.$(bld_trg).$(bld_trg_arch).$(bld_type))),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg).$(bld_trg_arch).$(bld_type)))
 else ifneq ($(strip $($(target)_INST.$(bld_trg).$(bld_trg_arch))),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg).$(bld_trg_arch)))
 else ifneq ($(strip $($(target)_INST.$(bld_trg).$(bld_type))),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg).$(bld_type)))
 else ifneq ($(strip $($(target)_INST.$(bld_trg_arch))),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg_arch)))
 else ifneq ($(strip $($(target)_INST.$(bld_trg))),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg)))
 else ifneq ($(strip $($(target)_INST.$(bld_type))),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_type)))
 else ifneq ($(strip $($(target)_INST)),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST))
 else
  local inst := $(definst)/
 endif
 INSTARGET_$(target) := $(patsubst %/,%/$(notdir $(out)),$(inst))

else # NOINST
 INSTARGET_$(target) :=
endif # NOINST

endef
$(eval-opt-var def_pass1_link_common)


#
# BLDPROGS (Pass 1)
#
define def_pass1_bldprog
# set NOINST if not forced installation before doing the usual stuff.
ifndef $(target)_INST
$(target)_NOINST := 1
endif
$(evalval def_pass1_link_common)
endef

EXT     := EXE
EXTPRE  := HOST
definst := $(PATH_BIN)
tool_prefix := LD
bld_trg_base_var := PLATFORM
$(foreach target, $(_ALL_BLDPROGS), \
	$(evalval def_pass1_bldprog))


#
# LIBRARIES (Pass 1)
#
EXT     := LIB
EXTPRE  :=
definst := $(PATH_LIB)
tool_prefix := AR
bld_trg_base_var := TARGET
$(foreach target, $(_ALL_LIBRARIES), \
	$(evalval def_pass1_link_common))


#
# DLLS  (Pass 1)
#
EXT     := DLL
EXTPRE  :=
definst := $(PATH_DLL)
tool_prefix := LD
bld_trg_base_var := TARGET
$(foreach target, $(_ALL_DLLS), \
	$(evalval def_pass1_link_common))


#
# IMPORT LIBRARIES (Pass 1)
#
#   - On OS/2 and windows these are libraries.
#   - On other platforms they are fake DLLs.
#
if1of ($(KBUILD_TARGET), nt os2 win win64 win32)
 EXT     := LIB
 EXTPRE  :=
 definst := $(PATH_LIB)
 tool_prefix := AR
 bld_trg_base_var := TARGET
 $(foreach target, $(_ALL_IMPORT_LIBS), \
	$(evalval def_pass1_link_common))
else
 EXT     := DLL
 EXTPRE  :=
 definst := $(PATH_DLL)
 tool_prefix := LD
 bld_trg_base_var := TARGET
 $(foreach target, $(_ALL_IMPORT_LIBS), \
	$(evalval def_pass1_link_common))
endif


#
# PROGRAMS (Pass 1)
#
EXT     := EXE
EXTPRE  :=
definst := $(PATH_BIN)
tool_prefix := LD
bld_trg_base_var := TARGET
$(foreach target, $(_ALL_PROGRAMS), \
	$(evalval def_pass1_link_common))


#
# SYSMODS (Pass 1)
#
EXT     := SYS
EXTPRE  :=
definst := $(PATH_SYS)
tool_prefix := LD
bld_trg_base_var := TARGET
$(foreach target, $(_ALL_SYSMODS), \
	$(evalval def_pass1_link_common))


#
# MISCBINS (Pass 1)
#
EXT     := BIN
EXTPRE  :=
definst := $(PATH_BIN)
tool_prefix := LD
bld_trg_base_var := TARGET
$(foreach target, $(_ALL_MISCBINS), \
	$(evalval def_pass1_link_common))


#
# INSTALLS (Pass 1)
# 	Note! INSTARGET_* for INSTALLS aren't available until later.
#
define def_pass1_install
local bld_type     := $(firstword $($(target)_BLD_TYPE)     $(KBUILD_TYPE))
local bld_trg      := $(firstword $($(target)_BLD_TRG)      $(KBUILD_TARGET))
local bld_trg_arch := $(firstword $($(target)_BLD_TRG_ARCH) $(KBUILD_TARGET_ARCH))
local bld_trg_cpu  := $(firstword $($(target)_BLD_TRG_CPU)  $(KBUILD_TARGET_CPU))
# TARGET_*
$(target)_1_TARGET := $(PATH_TARGET)/$(target).ins
TARGET_$(target)   := $($(target)_1_TARGET)

# INSTARGET_ later.
# PATH_*
local outbase      := $(call TARGET_BASE,$(target),$(target))
$(target)_0_OUTDIR := $(patsubst %/,%,$(dir $(outbase)))
PATH_$(target)     := $($(target)_0_OUTDIR)
endef # def_pass1_install
$(eval-opt-var def_pass1_install)
$(foreach target, $(_ALL_INSTALLS), \
	$(evalval def_pass1_install))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done pass 1)
endif




#
#
# Target lists - Pass 2
#
#


## @page pg_fetches 	Fetching Tools, Sources and Similar.
#
# The targets listed in the the FETCHES target list have the following attributes:
#       SOURCES
#       INST
#       FETCHTOOL
#       FETCHFLAGS
#       FETCHDIR
#       UNPACKTOOL
#       UNPACKFLAGS
#
# As usual the target name is an alias for 'creating' the target. Other
# aliases are:
#       pass_fetches
#       fetch
#       unfetch
#       download
#       unpack
#
# @remark
#
#   This is a little bit complex because we must guarantee that if a source file
#   changes only sligtly we must refetch it and to a proper unpacking of it. It
#   is also a desire that fetched archives and unpacked files can be deleted to
#   save space.
#
#   Thus, we must be able to cleanup what we've unpacked should any of the
#   sources be removed. We do this by maintaining a file listing the files
#   and directories that was unpacked. This operation is named 'unfetch'.
#
#   We make use of the SIZE and MD5 attributes for each of the sources to
#   create a digest that is stored in the primary target file. Subsequent
#   runswill compare their digest with it to decide if a refetch is required.
#   When a refetch is found necessary, an 'unfetch' is performed first to
#	clean out old files and directores. Note even changes in source order
#   will cause a refetch due to the way the digest is constructed and
#   evaluated.
#
#   By not depending directly on the archives (nor on any unpacked files)
#	but on a goal made up from the archive name, size and md5, we allow
#   the user to delete the archives. Naturally, this means we'll have to
#   check and fetch missing archives before attempting to unpack them.
#
# @remark
#
#	This feature will *NOT* work correctly with vanilla GNU make becuase
#   it makes use of includedep to avoid too many unnecessary files.
#
# @todo
#   0. Move the fetches out into a unit.
#   1. Download corruption / continuation.
#   2. It's quite possible that there is one too many indirect dependency now...
#

## generates the fetch rule
define def_fetch_src_fetch_rule
# Indirect goal for downloading something.
.PRECIOUS: $(out)
$(out) + $($(target)_$(srcname)_FETCH_2_OUTPUT) +| $($(target)_$(srcname)_FETCH_2_OUTPUT_MAYBE)  : \
		| $($(target)_$(srcname)_FETCH_2_DEPORD)
	%$$(call MSG_FETCH_DL,$(target),$(source),$(out))
	@## @todo do fancy stuff like download continuation.
	$$(QUIET)$$(RM) -f -- $(out)
	$(cmds)
	$$(QUIET)$(if $(md5),$$(MD5SUM_EXT) -b -C $(md5) $(out))



# Intermediate goal for making sure the md5 and size matches. it will (re) fetch the archive if necessary.
$(out).checked_$(md5)_$(size): $($(target)_$(srcname)_FETCH_2_DEPEND) | $($(target)_$(srcname)_FETCH_2_DEPORD)
	%$$(call MSG_FETCH_CHK,$(target),$(source),$(out))
	$$(QUIET)$$(RM) -f -- $$@
	@# (re)fetch the file if it doesn't exist or if it doesn't matches the md5.
	@## @todo do fancy stuff like download continuation.
	$$(QUIET)( test -f $(out) && $(if $(md5),$$(MD5SUM_EXT) -b -C $(md5) $(out), true) ) \
	          || (   $$(RM_EXT) -f $(out) \
		      && $$(MAKE)      $(out) -f $(MAKEFILE) --no-print-directory )
	$$(QUIET2)$$(APPEND) $$@

_TARGET_$(target)_FETCHED += $(out) $(out).checked_$(md5)_$(size)

# Just a little precaution.
.NOTPARALLEL: $(out) $(out).checked_$(md5)_$(size)

endef # def_fetch_src_fetch_rule
$(eval-opt-var def_fetch_src_fetch_rule)

## generates the unpack rule
define def_fetch_src_unpack_rule
# This is the unpack rule. it has an order-only dependency on the download check.
$(out) + $($(target)_$(srcname)_UNPACK_2_OUTPUT) +| $($(target)_$(srcname)_UNPACK_2_OUTPUT_MAYBE) : \
		$($(target)_$(srcname)_UNPACK_2_DEPEND) \
		| $($(target)_$(srcname)_UNPACK_2_DEPORD) \
		$(archive).checked_$(md5)_$(size) \
		$(dir $(out))
	%$$(call MSG_FETCH_UP,$(target),$(archive),$(inst))
	$$(QUIET)$$(RM) -f -- $(out)
	$$(QUIET)$$(MKDIR) -p -- $(dir $(out))
	@# if the source archive doesn't exist fetch it (may have been deleted to save space).
	$$(QUIET)test -f $(archive) \
	         || (   $$(RM_EXT) -f $(archive).checked_$(md5)_$(size) \
	             && $$(MAKE)      $(archive).checked_$(md5)_$(size) -f $(MAKEFILE) --no-print-directory )
	$(cmds)
	$$(QUIET2)$$(APPEND) $(out) $(notdir $(archive).checked_$(md5)_$(size))
	$$(QUIET2)$$(APPEND) $(out) $(notdir $(out))

$(eval _TARGET_$(target)_UNPACKED += $(out))
_TARGET_$(target)_DIGEST := $(_TARGET_$(target)_DIGEST)-$(srcname)_$(md5)_$(size)

.NOTPARALLEL: $(out)

endef # def_fetch_src_unpack_rule
$(eval-opt-var def_fetch_src_unpack_rule)

## Processes a fetch source
#
define def_fetch_src
#$ (warning dbg: def_fetch_src: source='$(source)' target='$(target)')

# common
local srcname := $(notdir $(source))
local inst := $(firstword \
	$($(target)_$(source)_INST)\
	$($(target)_$(srcname)_INST)\
	$($(source)_INST)\
	$($(srcname)_INST)\
	$($(target)_INST)\
)
ifneq ($(patsubst %/,ok,$(inst)),ok)
$(error kBuild: Bad or missing INST property for source '$(source)' in target '$(target)': $(inst))
endif
INSTARGET_$(target)_$(srcname) := $(inst)
local fetchdir := $(firstword \
	$($(target)_$(source)_FETCHDIR)\
	$($(target)_$(srcname)_FETCHDIR)\
	$($(source)_FETCHDIR)\
	$($(srcname)_FETCHDIR)\
	$($(target)_FETCHDIR)\
	$(FETCHDIR)\
	$(PATH_TARGET)\
)
local deps := \
	$($(target)_$(source)_DEPS)\
	$($(target)_$(srcname)_DEPS)\
	$($(source)_DEPS)\
	$($(srcname)_DEPS)\
	$($(target)_DEPS)
local orderdeps := \
	$($(target)_$(source)_ORDERDEPS)\
	$($(target)_$(srcname)_ORDERDEPS)\
	$($(source)_ORDERDEPS)\
	$($(srcname)_ORDERDEPS)\
	$($(target)_ORDERDEPS)
local md5 := $(firstword \
	$($(target)_$(source)_MD5)\
	$($(target)_$(srcname)_MD5)\
	$($(source)_MD5)\
	$($(srcname)_MD5)\
	$($(target)_MD5)\
)
local size := $(firstword \
	$($(target)_$(source)_SIZE)\
	$($(target)_$(srcname)_SIZE)\
	$($(source)_SIZE)\
	$($(srcname)_SIZE)\
	$($(target)_SIZE)\
)
clean_files += \
	$($(target)_$(source)_CLEAN)\
	$($(target)_$(srcname)_CLEAN)\
	$($(source)_CLEAN)\
	$($(srcname)_CLEAN)
local dep := # not legal for fetch and unpack tools


#
# The fetching.
#
local out := $(fetchdir)/$(srcname)
local archive := $(out)
TARGET_$(target)_$(srcname) := $(out)
$(target)_$(srcname)_1_TARGET = $(TARGET_$(target)_$(srcname))
local dirdep := $(call DIRDEP,$(fetchdir))
local tool := $(firstword \
	$($(target)_$(source)_FETCHTOOL)\
	$($(target)_$(srcname)_FETCHTOOL)\
	$($(target)_$(source)_TOOL)\
	$($(target)_$(srcname)_TOOL)\
	$($(source)_FETCHTOOL)\
	$($(srcname)_FETCHTOOL)\
	$($(source)_TOOL)\
	$($(srcname)_TOOL)\
	$($(target)_FETCHTOOL)\
	$($(target)_TOOL)\
	)
local flags :=\
	$(TOOL_$(tool)_FETCHFLAGS)\
	$(FETCHFLAGS)\
	$($(target)_FETCHFLAGS)\
	$($(srcname)_FETCHFLAGS)\
	$($(source)_FETCHFLAGS)\
	$($(target)_$(srcname)_FETCHFLAGS)\
	$($(target)_$(source)_FETCHFLAGS)

#$ (warning dbg: target=$(target) source=$(source) $(srcname)=$(srcname) tool=$(tool) out=$(out) flags=$(flags) dirdep=$(dirdep) fetchdir=$(fetchdir) md5=$(md5) size=$(size))

ifndef TOOL_$(tool)_FETCH_CMDS
$(warning kBuild: tools: \
	1 $($(target)_$(source)_FETCHTOOL)\
	2 $($(target)_$(srcname)_FETCHTOOL)\
	3 $($(target)_$(source)_TOOL)\
	4 $($(target)_$(srcname)_TOOL)\
	5 $($(source)_FETCHTOOL)\
	6 $($(srcname)_FETCHTOOL)\
	7 $($(source)_TOOL)\
	8 $($(srcname)_TOOL)\
	9 $($(target)_FETCHTOOL)\
	10 $($(target)_TOOL) )
$(error kBuild: TOOL_$(tool)_FETCH_CMDS is not defined. source=$(source) target=$(target) )
endif

# call the tool
local cmds := $(TOOL_$(tool)_FETCH_CMDS)
$(target)_$(srcname)_FETCH_2_OUTPUT := $(TOOL_$(tool)_FETCH_OUTPUT)
$(target)_$(srcname)_FETCH_2_OUTPUT_MAYBE := $(TOOL_$(tool)_FETCH_OUTPUT_MAYBE)
$(target)_$(srcname)_FETCH_2_DEPEND := $(TOOL_$(tool)_FETCH_DEPEND) $(deps)
$(target)_$(srcname)_FETCH_2_DEPORD := $(TOOL_$(tool)_FETCH_DEPORD) $(dirdep) $(orderdeps)

# generate the fetch rule.
$(eval $(def_fetch_src_fetch_rule))


#
# The unpacking / installing.
#
local out := $(inst)_kBuild_$(target)_$(srcname)_unpacked.lst
local dirdep := $(call DIRDEP,$(inst))
local tool := $(firstword \
	$($(target)_$(source)_UNPACKTOOL)\
	$($(target)_$(srcname)_UNPACKTOOL)\
	$($(target)_$(source)_TOOL)\
	$($(target)_$(srcname)_TOOL)\
	$($(source)_UNPACKTOOL)\
	$($(srcname)_UNPACKTOOL)\
	$($(source)_TOOL)\
	$($(srcname)_TOOL)\
	$($(target)_UNPACKTOOL)\
	$($(target)_TOOL) \
	)
ifeq ($(tool),)
local tool := $(toupper $(subst .,,$(suffix $(subst tar.,TAR,$(srcname)))))
$(evalval def_tools_include)
endif
local flags :=\
	$(TOOL_$(tool)_UNPACKFLAGS)\
	$(UNPACKFLAGS)\
	$($(target)_UNPACKFLAGS)\
	$($(srcname)_UNPACKFLAGS)\
	$($(source)_UNPACKFLAGS)\
	$($(target)_$(srcname)_UNPACKFLAGS)\
	$($(target)_$(source)_UNPACKFLAGS)

#$ (warning dbg: target=$(target) source=$(source) $(srcname)=$(srcname) tool=$(tool) out=$(out) flags=$(flags) dirdep=$(dirdep) inst=$(inst) md5=$(md5) size=$(size))
ifndef TOOL_$(tool)_UNPACK_CMDS
$(warning kBuild: tools: \
	1 $($(target)_$(source)_UNPACKTOOL)\
	2 $($(target)_$(srcname)_UNPACKTOOL)\
	3 $($(target)_$(source)_TOOL)\
	4 $($(target)_$(srcname)_TOOL)\
	5 $($(source)_UNPACKTOOL)\
	6 $($(srcname)_UNPACKTOOL)\
	7 $($(source)_TOOL)\
	8 $($(srcname)_TOOL)\
	9 $($(target)_UNPACKTOOL)\
	10 $($(target)_TOOL) \
	11 $(toupper $(subst tar.,TAR,$(ext $(srcname)))) \
	)
$(error kBuild: TOOL_$(tool)_UNPACK_CMDS is not defined. source=$(source) target=$(target) )
endif

# call the tool
local cmds := $(TOOL_$(tool)_UNPACK_CMDS)
$(target)_$(srcname)_UNPACK_2_OUTPUT := $(TOOL_$(tool)_UNPACK_OUTPUT)
$(target)_$(srcname)_UNPACK_2_OUTPUT_MAYBE := $(TOOL_$(tool)_UNPACK_OUTPUT_MAYBE)
$(target)_$(srcname)_UNPACK_2_DEPEND := $(TOOL_$(tool)_UNPACK_DEPEND) $(deps)
$(target)_$(srcname)_UNPACK_2_DEPORD := $(TOOL_$(tool)_UNPACK_DEPORD) $(dirdep) $(orderdeps)

# generate the fetch rule.
$(eval $(def_fetch_src_unpack_rule))

_DIRS += $(inst) $(fetchdir)

endef #	def_fetch_src
$(eval-opt-var def_fetch_src)


##
# Define the target level rules for a fetch.
# @param	target
# @param	out
# @param	inst
# @param	_TARGET_$(target)_UNPACKED
# @param	_TARGET_$(target)_DIGEST
# @param	bld_trg
# @param	bld_trg_arch
define def_fetch_rules

$(out).lst: $(_TARGET_$(target)_UNPACKED) | $(call DIRDEP,$(inst))
	%$$(call MSG_FETCH_OK,$(target))
	$$(QUIET)$$(RM) -f -- $$@ $$@.tmp
	$$(QUIET2)$$(APPEND) $$@.tmp '$(notdir $(out))'
	$$(QUIET)$(if $(_TARGET_$(target)_UNPACKED),$$(CAT_EXT) $(_TARGET_$(target)_UNPACKED) >> $$@.tmp)
	$$(QUIET)$$(MV) -f -- $$@.tmp $$@

$(out)_unfetched:
	%$$(call MSG_UNFETCH,$(target))
	$$(QUIET)$$(RM) -f -- $$(addprefix $(inst),$$(shell $$(CAT_EXT) $(out).lst 2> /dev/null | $$(SED) -e '/\/$$$$/d'))
	$$(QUIET)$$(RMDIR) -p --ignore-fail-on-non-empty --ignore-fail-on-not-exist -- $$(dir $$@) \
		$$(addprefix $(inst),$$(sort $$(dir $$(shell $$(CAT_EXT) $(out).lst 2> /dev/null))))
	$$(QUIET)$$(RM) -f -- $(out).lst $(out)
	$$(QUIET)$$(RMDIR) -p --ignore-fail-on-non-empty --ignore-fail-on-not-exist -- $$(dir $$@)

$(out): $(comp-vars _TARGET_$(target)_DIGEST_PREV,_TARGET_$(target)_DIGEST,FORCE) | $(call DIRDEP,$(inst))
	$$(QUIET)$$(RM) -f -- $$@
	%$$(if $$(_TARGET_$(target)_DIGEST),$$(if $$(eq $$(file-size $(out).lst),-1)\
		,$$(call MSG_REFETCH,$(target)),$$(call MSG_FETCH,$(target))),$$(call MSG_UNFETCH,$(target)))
	$$(QUIET)$(TEST_EXT) -f $(out).lst -- $$(MAKE) -f $(MAKEFILE) --no-print-directory $(out)_unfetched
	$$(QUIET)$$(if  $$(_TARGET_$(target)_DIGEST),$$(MAKE) -f $(MAKEFILE) --no-print-directory $(out).lst,$$(RMDIR) -p --ignore-fail-on-non-empty --ignore-fail-on-not-exist -- $$(dir $$@))
	$$(QUIET2)$$(if $$(_TARGET_$(target)_DIGEST),$$(APPEND) $$@ "_TARGET_$(target)_DIGEST_PREV := $(_TARGET_$(target)_DIGEST)")

.NOTPARALLEL: $(out).lst $(out)_unfetched $(out)

endef


##
# Deal with one fetch target.
# @param	target
# @param	bld_trg
# @param	bld_trg_arch
define def_fetch
# common
INSTARGET_$(target) := $($(target)_INST)
ifneq ($(patsubst %/,ok,$(INSTARGET_$(target))),ok)
$(error kBuild: Bad or missing INST property for target '$(target)'. \
	$(target)_INST='$($(target)_INST)' ($(origin $(target)_INST)))
endif
_TARGET_$(target)_FETCHED :=
_TARGET_$(target)_UNPACKED :=
_TARGET_$(target)_DIGEST :=
local clean_files := $($(target)_CLEAN) $($(target)_CLEAN.$(bld_trg)) $($(target)_CLEAN.$(bld_trg).$(bld_trg_arch)) $($(target)_CLEAN.$(bld_trg_arch)) $($(target)_CLEAN.$(KBUILD_TYPE))

# The 'sources'.
#$ (warning dbg fetch: target=$(target) sources=$($(target)_SOURCES) $($(target)_SOURCES.$(KBUILD_TYPE)) $($(target)_SOURCES.$(KBUILD_TARGET)) $($(target)_SOURCES.$(bld_trg_arch)) $($(target)_SOURCES.$(KBUILD_TARGET).$(bld_trg_arch)))
$(foreach source,$($(target)_SOURCES) $($(target)_SOURCES.$(KBUILD_TYPE)) $($(target)_SOURCES.$(bld_trg)) $($(target)_SOURCES.$(bld_trg_arch)) $($(target)_SOURCES.$(bld_trg).$(bld_trg_arch)),\
	$(evalval def_fetch_src))

# The target.
local inst := $(INSTARGET_$(target))
local out := $(inst)_kBuild_fetch_$(target)

$(eval includedep $(out))

$(eval $(def_fetch_rules))

# Define the aliases here (doesn't work if defined in def_fetch_rules, just like includedep).
$(target): $(out)
$(target)_unfetch: $(out)_unfetched

_FETCHES += $(out)
_DOWNLOADS += $(_TARGET_$(target)_FETCHED)
_UNPACKS += $(_TARGET_$(target)_UNPACKED)
_UNFETCHES += $(out)_unfetched
_DIRS += $(inst)
_CLEAN_FILES += $(clean_files)

endef
$(eval-opt-var def_fetch)

# Walk the FETCH target lists.
bld_trg := $(KBUILD_TARGET)
bld_trg_arch := $(KBUILD_TARGET_ARCH)
$(foreach target, $(_ALL_FETCHES), \
	$(evalvalctx def_fetch))

# some aliases.
download: $(_DOWNLOADS)
unpack: $(_UNPACKS)
fetch: $(_FETCHES)
unfetch: $(_UNFETCHES)

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done fetching targets)
endif



##
## Patching.
##
##
#define def_patch_src
#
#endef
#
#
## Deal with one patch target.
#define def_patch
#
#$(foreach source,$($(target)_SOURCES) $($(target)_SOURCES.$(KBUILD_TYPE)) $($(target)_SOURCES.$(KBUILD_TARGET)) $($(target)_SOURCES.$(KBUILD_TARGET_ARCH)) $($(target)_SOURCES.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)),\
#	$(evalval def_patch_src))
#
#_PATCHES +=
#endef
#
#$(foreach target, $(_ALL_PATCHES), \
#	$(evalval def_patch))
#


#
# Object processing.
#

## wrapper the compile command dependency check.
ifndef NO_COMPILE_CMDS_DEPS
 if1of ($(KMK_FEATURES),dot-must-make)
  _DEP_COMPILE_CMDS =
  # for debugging:  $$(warning MUST_MAKE=$$$$(comp-cmds-ex $$$$($(target)_$(subst :,_,$(source))_CMDS_PREV_), $$$$(commands $$@)) -> $$(comp-cmds-ex $$($(target)_$(subst :,_,$(source))_CMDS_PREV_),$$(commands $$@),FORCE))
 else
  _DEP_COMPILE_CMDS = $$(comp-cmds-ex $$($(target)_$(subst :,_,$(source))_CMDS_PREV_),$$(commands $(obj)),FORCE)
 endif
else
 _DEP_COMPILE_CMDS =
endif


## Generates the rules for building a specific object, and the aliases
# for building a source file.
# @param    $(obj)    The object file.
define def_target_source_rule
ifndef NO_COMPILE_CMDS_DEPS
$(obj): .MUST_MAKE = $$(comp-cmds-ex $$($(target)_$(subst :,_,$(source))_CMDS_PREV_),$$(commands $$@),FORCE)
endif
ifdef TOOL_$(tool)_COMPILE_$(type)_USES_KOBJCACHE
_OUT_FILES += $(outbase).koc
$(outbase).koc +| $(obj) $($(target)_$(source)_OUTPUT_) $($(target)_$(source)_OUTPUT_MAYBE_) : \
		$($(target)_$(source)_DEPEND_) \
		$(value _DEP_COMPILE_CMDS) \
		| \
		$($(target)_$(source)_DEPORD_) \
		$$$$($(target)_INTERMEDIATES) \
		$$$$($(target)_INTERMEDIATES.$(bld_trg)) \
		$$$$($(target)_INTERMEDIATES.$(bld_trg).$(bld_trg_arch)) \
		$$$$($(target)_INTERMEDIATES.$(bld_trg_arch)) \
		$$$$($(target)_INTERMEDIATES.$(bld_trg_cpu)) \
		$$$$($(target)_INTERMEDIATES.$(bld_type))
	%$$(call MSG_COMPILE,$(target),$(source),$$@,$(type))
else
$(obj) + $($(target)_$(source)_OUTPUT_) +| $($(target)_$(source)_OUTPUT_MAYBE_) : \
		$($(target)_$(source)_DEPEND_) \
		$(value _DEP_COMPILE_CMDS) \
		| \
		$($(target)_$(source)_DEPORD_) \
		$$$$($(target)_INTERMEDIATES) \
		$$$$($(target)_INTERMEDIATES.$(bld_trg)) \
		$$$$($(target)_INTERMEDIATES.$(bld_trg).$(bld_trg_arch)) \
		$$$$($(target)_INTERMEDIATES.$(bld_trg_arch)) \
		$$$$($(target)_INTERMEDIATES.$(bld_trg_cpu)) \
		$$$$($(target)_INTERMEDIATES.$(bld_type))
	%$$(call MSG_COMPILE,$(target),$(source),$$@,$(type))
ifdef TOOL_$(tool)_COMPILE_$(type)_DONT_PURGE_OUTPUT
	$$(QUIET)$$(RM) -f -- $(dep) $(obj) $($(target)_$(source)_OUTPUT_) $($(target)_OUTPUT_MAYBE_)
endif
endif

$($(target)_$(source)_CMDS_)

ifndef NO_COMPILE_CMDS_DEPS
	%$$(QUIET2)$$(APPEND) '$(dep)'
	%$$(QUIET2)$$(APPEND) '$(dep)' 'define $(target)_$(subst :,_,$(source))_CMDS_PREV_'
	%$$(QUIET2)$$(APPEND) -c '$(dep)' '$(obj)'
	%$$(QUIET2)$$(APPEND) '$(dep)' 'endef'
endif

$(basename $(notdir $(obj))).o: $(obj)
$(basename $(notdir $(obj))).obj: $(obj)

## @todo make this 'local cmds,output,output_maybe,depend and depord' in 0.2.x or when a new kb-src-one is added.
$(target)_$(source)_CMDS_ :=
$(target)_$(source)_OUTPUT_ :=
$(target)_$(source)_OUTPUT_MAYBE_ :=
$(target)_$(source)_DEPEND_ :=
$(target)_$(source)_DEPORD_ :=
endef # def_target_source_rule
$(eval-opt-var def_target_source_rule)


## wrapper the link command dependency check.
ifndef NO_LINK_CMDS_DEPS
 if1of ($(KMK_FEATURES),dot-must-make)
  _DEP_LINK_CMDS =
 else
  _DEP_LINK_CMDS = $$(comp-cmds-ex $$($(target)_CMDS_PREV_),$$(commands $(out)),FORCE)
 endif
else
 _DEP_LINK_CMDS =
endif

## Generate the link rule for a target.
# @param    $(target)               The normalized target name.
# @param    $(dirdep)               Directories we depend upon begin created before linking.
# @param    $(dep)                  The name of the dependency file.
# @param    $(out)
# @param    $($(target)_2_OUTPUT)   Output files from the link.
# @param    $($(target)_2_OUTPUT_MAYBE)	Output files that the link may perhaps create.
# @param    $($(target)_2_DEPEND)   Dependencies.
# @param    $($(target)_2_DEPORD)   Dependencies which should only affect build order.
# @param    $(cmds)                 The link commands.
# @param    $($(target)_CMDS_PREV_) The link commands from the previous run.
define def_link_rule
ifndef NO_LINK_CMDS_DEPS
$(out): .MUST_MAKE = $$(comp-cmds-ex $$($(target)_CMDS_PREV_),$$(commands $$@),FORCE)
endif
$(out) + $($(target)_2_OUTPUT) +| $($(target)_2_OUTPUT_MAYBE) : \
		$$$$($(target)_2_DEPEND) \
		$(value _DEP_LINK_CMDS) \
		| \
		$$$$($(target)_2_DEPORD)
	%$$(call MSG_LINK,$(target),$$@,$(tool_do))
	$$(QUIET)$$(RM) -f -- $(dep) $(out) $($(target)_2_OUTPUT) $($(target)_2_OUTPUT_MAYBE)

$(cmds)

ifndef NO_LINK_CMDS_DEPS
	%$$(QUIET2)$$(APPEND) '$(dep)' 'define $(target)_CMDS_PREV_'
	%$$(QUIET2)$$(APPEND) -c '$(dep)' '$(out)'
	%$$(QUIET2)$$(APPEND) '$(dep)' 'endef'
endif

$(basename $(notdir $(out))):: $(out)

endef # def_link_rule
$(eval-opt-var def_link_rule)


## Generate the link & lib install rule
# @param    $(target)   Normalized target name.
# @param    $(out)      The build target.
# @param    $(INSTARGET_$(target))  The installation targets.
# @param    $(mode)     The file mode (optional)
define def_link_install_rule
$(INSTARGET_$(target)) : $(out) | $(call DIRDEP,$(dir $(INSTARGET_$(target))))
	%$$(call MSG_INST_TRG,$(target),$(out),$$@)
	$$(QUIET)$$(INSTALL) $(if $(mode),-m $(mode)) $(if $(uid),-o $(uid)) $(if $(gid),-g $(gid)) -- $(out) $$@

ifdef KBUILD_DO_AUTO_INSTALL
$(basename $(notdir $(out))):: $(INSTARGET_$(target))
endif
endef # def_link_install_rule


## def_src_handler_*
#
# @{
define def_src_handler_c
local type := C
 $(kb-src-one 2)
endef

define def_src_handler_cxx
local type := CXX
 $(kb-src-one 2)
endef

define def_src_handler_objc
local type := OBJC
 $(kb-src-one 2)
endef

define def_src_handler_objcxx
local type := OBJCXX
 $(kb-src-one 2)
endef

define def_src_handler_asm
local type := AS
 $(kb-src-one 2)
endef

define def_src_handler_rc
local type := RC
 $(kb-src-one 2)
endef

define def_src_handler_obj
ifeq ($(defpath),)
 $(target)_2_OBJS += $(source)
else
 $(target)_2_OBJS += $(abspathex $(source), $(defpath))
endif
endef
## @}

## Handle one source.
# .
define def_src_handler_one
local suff := $(suffix $(source))
local src_handler := $(firstword $(filter $(suff):%, $($(target)_$(source)_SRC_HANDLERS) $($(source)_SRC_HANDLERS) $(target_src_handlers) ))
local handler := $(patsubst $(suff):%,%,$(src_handler))
ifneq ($(handler),)
 $(evalvalctx $(handler))
else
 othersrc += $(source)
endif
endef

## Generic macro for processing all target sources.
# @param    $(target)   Normalized target name.
# @param    $(defpath)
# @param    much-more...
# @returns  othersrc, $(target)_2_OBJS, ++
define def_target_sources
local target_src_handlers := $($(target)_SRC_HANDLERS) $(KBUILD_SRC_HANDLERS)
$(foreach source,\
	$($(target)_SOURCES)\
	$($(target)_SOURCES.$(bld_trg))\
	$($(target)_SOURCES.$(bld_trg).$(bld_trg_arch))\
	$($(target)_SOURCES.$(bld_trg_arch))\
	$($(target)_SOURCES.$(bld_trg_cpu))\
	$($(target)_SOURCES.$(bld_type))\
	,$(evalval def_src_handler_one) )

$(foreach source,\
	$($(target)_GEN_SOURCES_)\
	$($(target)_GEN_SOURCES_.$(bld_trg))\
	$($(target)_GEN_SOURCES_.$(bld_trg).$(bld_trg_arch))\
	$($(target)_GEN_SOURCES_.$(bld_trg_arch))\
	$($(target)_GEN_SOURCES_.$(bld_trg_cpu))\
	$($(target)_GEN_SOURCES_.$(bld_type))\
	,$(evalval def_src_handler_one) )
endef # def_target_sources
$(eval-opt-var def_target_sources)



## Generic macro for generating the install rule(s) for a target
# and update the globals with default out.
#
# @param	$(target)   Normalized target name.
# @param	$(out)      The output file.
# @param	$(definst)  The default _INST value.
# @param	$(typevar)  The name of the variable with all the root targets of its type.
# @remark   Only library uses this now.
define def_target_install_pluss
ifeq ($(strip $($(target)_NOINST) $($(target)_NOINST.$(bld_trg)) $($(target)_NOINST.$(bld_trg).$(bld_trg_arch)) $($(target)_NOINST.$(bld_trg).$(bld_trg_arch).$(bld_type))  $($(target)_NOINST.$(bld_trg_arch)) $($(target)_NOINST.$(bld_trg_cpu)) $($(target)_NOINST.$(bld_trg_type))),)
 ifneq ($(strip $($(target)_INST.$(bld_trg).$(bld_trg_arch).$(bld_type))),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg).$(bld_trg_arch).$(bld_type)))
 else ifneq ($(strip $($(target)_INST.$(bld_trg).$(bld_trg_arch))),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg).$(bld_trg_arch)))
 else ifneq ($(strip $($(target)_INST.$(bld_trg).$(bld_type))),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg).$(bld_type)))
 else ifneq ($(strip $($(target)_INST.$(bld_trg_arch))),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg_arch)))
 else ifneq ($(strip $($(target)_INST.$(bld_trg))),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg)))
 else ifneq ($(strip $($(target)_INST.$(bld_type))),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_type)))
 else ifneq ($(strip $($(target)_INST)),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST))
 else
  local inst := $(definst)/
 endif
 INSTARGET_$(target) := $(patsubst %/,%/$(notdir $(out)),$(inst))
 local mode := $(firstword \
 	$($(target)_MODE.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
 	$($(target)_MODE.$(bld_trg).$(bld_trg_arch)) \
 	$($(target)_MODE.$(bld_trg).$(bld_type)) \
 	$($(target)_MODE.$(bld_trg_arch)) \
 	$($(target)_MODE.$(bld_trg)) \
 	$($(target)_MODE.$(bld_type)) \
 	$($(target)_MODE) )
 local uid := $(firstword \
 	$($(target)_UID.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
 	$($(target)_UID.$(bld_trg).$(bld_trg_arch)) \
 	$($(target)_UID.$(bld_trg).$(bld_type)) \
 	$($(target)_UID.$(bld_trg_arch)) \
 	$($(target)_UID.$(bld_trg)) \
 	$($(target)_UID.$(bld_type)) \
 	$($(target)_UID) )
 local gid := $(firstword \
 	$($(target)_GID.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
 	$($(target)_GID.$(bld_trg).$(bld_trg_arch)) \
 	$($(target)_GID.$(bld_trg).$(bld_type)) \
 	$($(target)_GID.$(bld_trg_arch)) \
 	$($(target)_GID.$(bld_trg)) \
 	$($(target)_GID.$(bld_type)) \
 	$($(target)_GID) )

 # generate the install rule
$(eval $(def_link_install_rule))

 _INSTALLS_FILES += $(INSTARGET_$(target))

 ifdef KBUILD_DO_AUTO_INSTALL
  $(typevar) += $(INSTARGET_$(target))
 else
  $(typevar) += $(out)
 endif
else # _NOINST
 $(typevar) += $(out)
endif

_OUT_FILES += $($(target)_2_OUTPUT) $($(target)_2_OUTPUT_MAYBE) $(out)
_CLEAN_FILES += $($(target)_CLEAN) $($(target)_CLEAN.$(bld_trg)) $($(target)_CLEAN.$(bld_trg).$(bld_trg_arch)) $($(target)_CLEAN.$(bld_trg_arch)) $($(target)_CLEAN.$(bld_trg_cpu)) $($(target)_CLEAN.$(bld_type))
_DIRS += $($(target)_BLDDIRS) $($(target)_BLDDIRS.$(bld_trg)) $($(target)_BLDDIRS.$(bld_trg).$(bld_trg_arch)) $($(target)_BLDDIRS.$(bld_trg_arch)) $($(target)_BLDDIRS.$(bld_trg_cpu)) $($(target)_BLDDIRS.$(bld_type))
_OBJS += $($(target)_2_OBJS)

endef # def_target_install_pluss



#
# LIBRARIES
#

## Library (one).
# @param    $(target)   Normalized library (target) name.
define def_lib
# library basics
## @todo prefix
local bld_type    := $(firstword $($(target)_BLD_TYPE)     $(KBUILD_TYPE))
local bld_trg     := $(firstword $($(target)_BLD_TRG)      $(KBUILD_TARGET))
local bld_trg_arch:= $(firstword $($(target)_BLD_TRG_ARCH) $(KBUILD_TARGET_ARCH))
local bld_trg_cpu := $(firstword $($(target)_BLD_TRG_CPU)  $(KBUILD_TARGET_CPU))
local tool        := $(call _TARGET_TOOL,$(target),AR)
ifeq ($(tool),)
$(error kBuild: Library target $(target) does not have a tool defined!)
endif
local name        := $(firstword\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg))\
	$($(target)_NAME.$(bld_type))\
	$($(target)_NAME)\
	$(target))
local outbase     := $(call TARGET_BASE,$(name),$(target))
$(target)_0_OUTDIR:= $(patsubst %/,%,$(dir $(outbase)))
PATH_$(target)    := $($(target)_0_OUTDIR)
local suff        := $(firstword\
	$($(target)_LIBSUFF.$(bld_trg).$(bld_trg_arch))\
	$($(target)_LIBSUFF.$(bld_trg))\
	$($(target)_LIBSUFF)\
	$(TOOL_$(tool)_ARLIBSUFF.$(bld_trg).$(bld_trg_arch))\
	$(TOOL_$(tool)_ARLIBSUFF.$(bld_trg))\
	$(TOOL_$(tool)_ARLIBSUFF)\
	$(SUFF_LIB))
local out         := $(outbase)$(suff)
local defpath     := $(firstword $($(target)_PATH) $($(target)_DEFPATH))
TARGET_$(target)  := $(out)
$(target)_1_TARGET:= $(out)
# no local here - must be writable across some foreachs.
othersrc          :=
$(target)_2_OBJS  :=

# Do units pre source callouts.
local units       := \
	$($(target)_USES.$(bld_trg).$(bld_trg_arch))\
	$($(target)_USES.$(bld_trg_arch))\
	$($(target)_USES.$(bld_trg))\
	$($(target)_USES.$(bld_type))\
	$($(target)_USES)
$(foreach unit,$(units),$(evalval def_unit_$(unit)_target_pre))

# source -> object
$(evalval def_target_sources)

# library linking
local tool        := $(call _TARGET_TOOL,$(target),AR)
local name        := $(firstword\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg))\
	$($(target)_NAME.$(bld_type))\
	$($(target)_NAME)\
	$(target))
local outbase     := $(call TARGET_BASE,$(name),$(target))
local flags       :=\
	$(TOOL_$(tool)_ARFLAGS)\
	$(TOOL_$(tool)_ARFLAGS.$(bld_type))\
	$(ARFLAGS)\
	$(ARFLAGS.$(bld_type))\
	$($(target)_ARFLAGS)\
	$($(target)_ARFLAGS.$(bld_type)) \
	$($(target)_ARFLAGS.$(bld_trg)) \
	$($(target)_ARFLAGS.$(bld_trg_arch)) \
	$($(target)_ARFLAGS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_ARFLAGS.$(bld_trg_cpu))
local dirdep      := $(call DIRDEP,$(dir $(out)))
local deps        := \
	$($(target)_DEPS.$(bld_trg_cpu)) \
	$($(target)_DEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_DEPS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_DEPS.$(bld_trg).$(bld_type)) \
	$($(target)_DEPS.$(bld_trg_arch)) \
	$($(target)_DEPS.$(bld_trg)) \
	$($(target)_DEPS.$(bld_type)) \
	$($(target)_DEPS) \
	$($(target)_LNK_DEPS.$(bld_trg_cpu)) \
	$($(target)_LNK_DEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_LNK_DEPS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_LNK_DEPS.$(bld_trg).$(bld_type)) \
	$($(target)_LNK_DEPS.$(bld_trg_arch)) \
	$($(target)_LNK_DEPS.$(bld_trg)) \
	$($(target)_LNK_DEPS.$(bld_type)) \
	$($(target)_LNK_DEPS)
local orderdeps   := \
	$($(target)_ORDERDEPS.$(bld_trg_cpu)) \
	$($(target)_ORDERDEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_ORDERDEPS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_ORDERDEPS.$(bld_trg).$(bld_type)) \
	$($(target)_ORDERDEPS.$(bld_trg_arch)) \
	$($(target)_ORDERDEPS.$(bld_trg)) \
	$($(target)_ORDERDEPS.$(bld_type)) \
	$($(target)_ORDERDEPS) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg_cpu)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg).$(bld_type)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg_arch)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg)) \
	$($(target)_LNK_ORDERDEPS.$(bld_type)) \
	$($(target)_LNK_ORDERDEPS)

# Adjust paths if we got a default path.
ifneq ($(defpath),)
 local deps       := $(abspathex $(deps),$(defpath))
 local orderdeps  := $(abspathex $(orderdeps),$(defpath))
 othersrc := $(abspathex $(othersrc),$(defpath))
endif


# Custom pre-link actions.
## @todo bld_trg_cpu is missing here.
ifdef $(target)_PRE_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type)
 local pre_cmds := $($(target)_PRE_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type))
else ifdef $(target)_PRE_CMDS.$(bld_trg).$(bld_trg_arch)
 local pre_cmds := $($(target)_PRE_CMDS.$(bld_trg).$(bld_trg_arch))
else ifdef $(target)_PRE_CMDS.$(bld_trg).$(bld_type)
 local pre_cmds := $($(target)_PRE_CMDS.$(bld_trg).$(bld_type))
else ifdef $(target)_PRE_CMDS.$(bld_trg_arch)
 local pre_cmds := $($(target)_PRE_CMDS.$(bld_trg_arch))
else ifdef $(target)_PRE_CMDS.$(bld_trg)
 local pre_cmds := $($(target)_PRE_CMDS.$(bld_trg))
else ifdef $(target)_PRE_CMDS.$(bld_type)
 local pre_cmds := $($(target)_PRE_CMDS.$(bld_type))
else ifdef $(target)_PRE_CMDS
 local pre_cmds := $($(target)_PRE_CMDS)
else ifdef PRE_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type)
 local pre_cmds := $(PRE_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type))
else ifdef PRE_CMDS.$(bld_trg).$(bld_trg_arch)
 local pre_cmds := $(PRE_CMDS.$(bld_trg).$(bld_trg_arch))
else ifdef PRE_CMDS.$(bld_trg).$(bld_type)
 local pre_cmds := $(PRE_CMDS.$(bld_trg).$(bld_type))
else ifdef PRE_CMDS.$(bld_trg_arch)
 local pre_cmds := $(PRE_CMDS.$(bld_trg_arch))
else ifdef PRE_CMDS.$(bld_trg)
 local pre_cmds := $(PRE_CMDS.$(bld_trg))
else ifdef PRE_CMDS.$(bld_type)
 local pre_cmds := $(PRE_CMDS.$(bld_type))
else
 local pre_cmds := $(PRE_CMDS)
endif

# Custom post-link actions.
ifdef $(target)_POST_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type)
 local post_cmds := $($(target)_POST_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type))
else ifdef $(target)_POST_CMDS.$(bld_trg).$(bld_trg_arch)
 local post_cmds := $($(target)_POST_CMDS.$(bld_trg).$(bld_trg_arch))
else ifdef $(target)_POST_CMDS.$(bld_trg).$(bld_type)
 local post_cmds := $($(target)_POST_CMDS.$(bld_trg).$(bld_type))
else ifdef $(target)_POST_CMDS.$(bld_trg_arch)
 local post_cmds := $($(target)_POST_CMDS.$(bld_trg_arch))
else ifdef $(target)_POST_CMDS.$(bld_trg)
 local post_cmds := $($(target)_POST_CMDS.$(bld_trg))
else ifdef $(target)_POST_CMDS.$(bld_type)
 local post_cmds := $($(target)_POST_CMDS.$(bld_type))
else ifdef $(target)_POST_CMDS
 local post_cmds := $($(target)_POST_CMDS)
else ifdef POST_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type)
 local post_cmds := $(POST_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type))
else ifdef POST_CMDS.$(bld_trg).$(bld_trg_arch)
 local post_cmds := $(POST_CMDS.$(bld_trg).$(bld_trg_arch))
else ifdef POST_CMDS.$(bld_trg).$(bld_type)
 local post_cmds := $(POST_CMDS.$(bld_trg).$(bld_type))
else ifdef POST_CMDS.$(bld_trg_arch)
 local post_cmds := $(POST_CMDS.$(bld_trg_arch))
else ifdef POST_CMDS.$(bld_trg)
 local post_cmds := $(POST_CMDS.$(bld_trg))
else ifdef POST_CMDS.$(bld_type)
 local post_cmds := $(POST_CMDS.$(bld_type))
else
 local post_cmds := $(POST_CMDS)
endif

# eliminate this guy?
local objs = $($(target)_2_OBJS)

# dependency file
local dep := $(out)$(SUFF_DEP)
ifndef NO_LINK_CMDS_DEPS
 _DEPFILES_INCLUDED += $(dep)
 ifdef KB_HAVE_INCLUDEDEP_QUEUE
  includedep-queue $(dep)
 else
  includedep $(dep)
 endif
endif

# check that the tool is defined.
ifndef TOOL_$(tool)_LINK_LIBRARY_CMDS
$(warning kBuild: tools: \
	1 $($(target)_$(source)TOOL.$(bld_trg).$(bld_trg_arch)) \
	2 $($(target)_$(source)TOOL.$(bld_trg)) \
	3 $($(target)_$(source)TOOL) \
	4 $($(target)_TOOL.$(bld_trg).$(bld_trg_arch)) \
	5 $($(target)_TOOL.$(bld_trg)) \
	6 $($(target)_TOOL) \
	7 $($(source)TOOL) \
	8 $($(source)TOOL.$(bld_trg).$(bld_trg_arch)) \
	9 $($(source)TOOL.$(bld_trg)) \
	10 $(TOOL.$(bld_trg).$(bld_trg_arch)) \
	11 $(TOOL.$(bld_trg)) \
	12 $(TOOL) )
$(error kBuild: TOOL_$(tool)_LINK_LIBRARY_CMDS isn't defined! target=$(target) )
endif

# call the tool
local cmds := $(TOOL_$(tool)_LINK_LIBRARY_CMDS)
ifneq ($(pre_cmds),)
 local cmds := $(TAB)$(pre_cmds)$(NL)$(TAB)$(cmds)
endif
ifneq ($(post_cmds),)
 local cmds  := $(cmds)$(NL)$(TAB)$(post_cmds)
endif
$(target)_2_OUTPUT := $(TOOL_$(tool)_LINK_LIBRARY_OUTPUT)
$(target)_2_OUTPUT_MAYBE := $(TOOL_$(tool)_LINK_LIBRARY_OUTPUT_MAYBE)
$(target)_2_DEPEND := $(TOOL_$(tool)_LINK_LIBRARY_DEPEND) $(deps) $($(target)_2_OBJS)
$(target)_2_DEPORD := $(TOOL_$(tool)_LINK_LIBRARY_DEPORD) $(dirdep) $(orderdeps)

# generate the link rule.
$(eval $(def_link_rule))

# installing and globals
$(evalval def_target_install_pluss)
endef
$(eval-opt-var def_lib)

# Process libraries
definst := $(PATH_LIB)
typevar := _LIBS
tool_do := LINK_LIBRARY
mode := 0644
$(foreach target, $(_ALL_LIBRARIES), $(evalval def_lib))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done library targets)
endif


#
# Link operations.
#

##
# Link prolog
#
# @param    $(target)   Normalized target name.
# @param    $(EXT)      EXE,DLL,SYS.
# @param    $(definst)  The default _INST value.
# @param    $(typevar)  The name of the variable with all the root targets of its type.
define def_link_common
# basics
local bld_type    := $(firstword $($(target)_BLD_TYPE)     $(KBUILD_TYPE))
local bld_trg     := $(firstword $($(target)_BLD_TRG)      $(BUILD_$(bld_trg_base_var)))
local bld_trg_arch:= $(firstword $($(target)_BLD_TRG_ARCH) $(BUILD_$(bld_trg_base_var)_ARCH))
local bld_trg_cpu := $(firstword $($(target)_BLD_TRG_CPU)  $(BUILD_$(bld_trg_base_var)_CPU))

local tool        := $(call _TARGET_TOOL,$(target),LD)
local name        := $(firstword\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg))\
	$($(target)_NAME.$(bld_type))\
	$($(target)_NAME)\
	$(target))
local outbase     := $(call TARGET_BASE,$(name),$(target))
$(target)_0_OUTDIR:= $(patsubst %/,%,$(dir $(outbase)))
PATH_$(target)    := $($(target)_0_OUTDIR)
local suff := $(firstword \
	$($(target)_$(EXT)SUFF.$(bld_trg).$(bld_trg_arch))\
	$($(target)_$(EXT)SUFF.$(bld_trg))\
	$($(target)_$(EXT)SUFF)\
	$(TOOL_$(tool)_LD$(EXT)SUFF.$(bld_trg).$(bld_trg_arch))\
	$(TOOL_$(tool)_LD$(EXT)SUFF.$(bld_trg))\
	$(TOOL_$(tool)_LD$(EXT)SUFF)\
	$($(EXTPRE)SUFF_$(EXT)) )
local out         := $(outbase)$(suff)
TARGET_$(target)  := $(out)
$(target)_1_TARGET:= $(out)
local defpath     := $(firstword $($(target)_PATH) $($(target)_DEFPATH))
# no local here - must be writable across some foreachs.
othersrc          :=
$(target)_2_OBJS  :=

# Do units pre source callouts.
local units       := \
	$($(target)_USES.$(bld_trg).$(bld_trg_arch))\
	$($(target)_USES.$(bld_trg_arch))\
	$($(target)_USES.$(bld_trg))\
	$($(target)_USES.$(bld_type))\
	$($(target)_USES)
$(foreach unit,$(units),$(evalval def_unit_$(unit)_target_pre))

# source -> object
$(evalval def_target_sources)

# more link stuff.
local tool        := $(call _TARGET_TOOL,$(target),LD)
local name        := $(firstword\
	$($(target)_NAME.$(bld_trg).$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg_arch))\
	$($(target)_NAME.$(bld_trg))\
	$($(target)_NAME.$(bld_type))\
	$($(target)_NAME)\
	$(target))
local outbase     := $(call TARGET_BASE,$(name),$(target))
local flags       :=\
	$(TOOL_$(tool)_LDFLAGS)\
	$(TOOL_$(tool)_LDFLAGS.$(bld_type))\
	$(TOOL_$(tool)_LDFLAGS.$(bld_trg))\
	$(TOOL_$(tool)_LDFLAGS.$(bld_trg_arch))\
	$(TOOL_$(tool)_LDFLAGS.$(bld_trg).$(bld_trg_arch))\
	$(TOOL_$(tool)_LDFLAGS.$(bld_trg_cpu))\
	$(foreach sdk, $(SDKS) \
	               $(SDKS.$(bld_type)) \
	               $(SDKS.$(bld_trg)) \
	               $(SDKS.$(bld_trg_arch)) \
	               $(SDKS.$(bld_trg).$(bld_trg_arch)),\
		$(SDK_$(sdk)_LDFLAGS)\
		$(SDK_$(sdk)_LDFLAGS.$(bld_type))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg_arch))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg).$(bld_trg_arch))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg_cpu)))\
	$(LDFLAGS)\
	$(LDFLAGS.$(bld_type))\
	$(LDFLAGS.$(bld_trg))\
	$(LDFLAGS.$(bld_trg_arch))\
	$(LDFLAGS.$(bld_trg).$(bld_trg_arch))\
	$(LDFLAGS.$(bld_trg_cpu))\
	$(foreach sdk, $($(target)_SDKS) \
	               $($(target)_SDKS.$(bld_type)) \
	               $($(target)_SDKS.$(bld_trg)) \
	               $($(target)_SDKS.$(bld_trg_arch)) \
	               $($(target)_SDKS.$(bld_trg).$(bld_trg_arch)),\
		$(SDK_$(sdk)_LDFLAGS)\
		$(SDK_$(sdk)_LDFLAGS.$(bld_type))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg_arch))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg).$(bld_trg_arch))\
		$(SDK_$(sdk)_LDFLAGS.$(bld_trg_cpu)))\
	$($(target)_LDFLAGS)\
	$($(target)_LDFLAGS.$(bld_type))\
	$($(target)_LDFLAGS.$(bld_trg))\
	$($(target)_LDFLAGS.$(bld_trg_arch))\
	$($(target)_LDFLAGS.$(bld_trg).$(bld_trg_arch))\
	$($(target)_LDFLAGS.$(bld_trg_cpu))
local libs        :=\
	$($(target)_LIBS.$(bld_trg_cpu))\
	$($(target)_LIBS.$(bld_trg).$(bld_trg_arch))\
	$($(target)_LIBS.$(bld_trg_arch))\
	$($(target)_LIBS.$(bld_trg))\
	$($(target)_LIBS.$(bld_type))\
	$($(target)_LIBS)\
	$(foreach sdk, $($(target)_SDKS.$(bld_trg).$(bld_trg_arch)) \
		       $($(target)_SDKS.$(bld_trg_arch)) \
		       $($(target)_SDKS.$(bld_trg)) \
		       $($(target)_SDKS.$(bld_type)) \
		       $($(target)_SDKS),\
		$(SDK_$(sdk)_LIBS.$(bld_trg_cpu))\
		$(SDK_$(sdk)_LIBS.$(bld_trg).$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBS.$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBS.$(bld_trg))\
		$(SDK_$(sdk)_LIBS.$(bld_type))\
		$(SDK_$(sdk)_LIBS))\
	$(LIBS.$(bld_trg_cpu))\
	$(LIBS.$(bld_trg).$(bld_trg_arch))\
	$(LIBS.$(bld_trg_arch))\
	$(LIBS.$(bld_trg))\
	$(LIBS.$(bld_type))\
	$(LIBS)\
	$(foreach sdk, $(SDKS.$(bld_trg).$(bld_trg_arch)) \
	               $(SDKS.$(bld_trg_arch)) \
	               $(SDKS.$(bld_trg)) \
	               $(SDKS.$(bld_type)) \
	               $(SDKS),\
		$(SDK_$(sdk)_LIBS.$(bld_trg_cpu))\
		$(SDK_$(sdk)_LIBS.$(bld_trg).$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBS.$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBS.$(bld_trg))\
		$(SDK_$(sdk)_LIBS.$(bld_type))\
		$(SDK_$(sdk)_LIBS))\
	$(TOOL_$(tool)_LIBS.$(bld_trg_cpu))\
	$(TOOL_$(tool)_LIBS.$(bld_trg).$(bld_trg_arch))\
	$(TOOL_$(tool)_LIBS.$(bld_trg_arch))\
	$(TOOL_$(tool)_LIBS.$(bld_trg))\
	$(TOOL_$(tool)_LIBS.$(bld_type))\
	$(TOOL_$(tool)_LIBS)
local libpath    :=\
	$($(target)_LIBPATH.$(bld_trg_cpu))\
	$($(target)_LIBPATH.$(bld_trg).$(bld_trg_arch))\
	$($(target)_LIBPATH.$(bld_trg_arch))\
	$($(target)_LIBPATH.$(bld_trg))\
	$($(target)_LIBPATH.$(bld_type))\
	$($(target)_LIBPATH)\
	$(foreach sdk, $($(target)_SDKS.$(bld_trg).$(bld_trg_arch)) \
		       $($(target)_SDKS.$(bld_trg_arch)) \
		       $($(target)_SDKS.$(bld_trg)) \
		       $($(target)_SDKS.$(bld_type)) \
		       $($(target)_SDKS),\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg_cpu))\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg).$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg))\
		$(SDK_$(sdk)_LIBPATH.$(bld_type))\
		$(SDK_$(sdk)_LIBPATH))\
	$(LIBPATH.$(bld_trg_cpu))\
	$(LIBPATH.$(bld_trg).$(bld_trg_arch))\
	$(LIBPATH.$(bld_trg_arch))\
	$(LIBPATH.$(bld_trg))\
	$(LIBPATH.$(bld_type))\
	$(LIBPATH)\
	$(foreach sdk, $(SDKS.$(bld_trg).$(bld_trg_arch)) \
	               $(SDKS.$(bld_trg_arch)) \
	               $(SDKS.$(bld_trg)) \
	               $(SDKS.$(bld_type)) \
	               $(SDKS),\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg_cpu))\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg).$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg_arch))\
		$(SDK_$(sdk)_LIBPATH.$(bld_trg))\
		$(SDK_$(sdk)_LIBPATH.$(bld_type))\
		$(SDK_$(sdk)_LIBPATH))\
	$(TOOL_$(tool)_LIBPATH.$(bld_trg_cpu))\
	$(TOOL_$(tool)_LIBPATH.$(bld_trg).$(bld_trg_arch))\
	$(TOOL_$(tool)_LIBPATH.$(bld_trg_arch))\
	$(TOOL_$(tool)_LIBPATH.$(bld_trg))\
	$(TOOL_$(tool)_LIBPATH.$(bld_type))\
	$(TOOL_$(tool)_LIBPATH)
local dirdep      := $(call DIRDEP,$(dir $(out)))
local deps        := \
	$($(target)_DEPS.$(bld_trg_cpu)) \
	$($(target)_DEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_DEPS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_DEPS.$(bld_trg).$(bld_type)) \
	$($(target)_DEPS.$(bld_trg_arch)) \
	$($(target)_DEPS.$(bld_trg)) \
	$($(target)_DEPS.$(bld_type)) \
	$($(target)_DEPS) \
	$($(target)_LNK_DEPS.$(bld_trg_cpu)) \
	$($(target)_LNK_DEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_LNK_DEPS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_LNK_DEPS.$(bld_trg).$(bld_type)) \
	$($(target)_LNK_DEPS.$(bld_trg_arch)) \
	$($(target)_LNK_DEPS.$(bld_trg)) \
	$($(target)_LNK_DEPS.$(bld_type)) \
	$($(target)_LNK_DEPS)
local orderdeps   := \
	$($(target)_ORDERDEPS.$(bld_trg_cpu)) \
	$($(target)_ORDERDEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_ORDERDEPS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_ORDERDEPS.$(bld_trg).$(bld_type)) \
	$($(target)_ORDERDEPS.$(bld_trg_arch)) \
	$($(target)_ORDERDEPS.$(bld_trg)) \
	$($(target)_ORDERDEPS.$(bld_type)) \
	$($(target)_ORDERDEPS) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg_cpu)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg).$(bld_type)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg_arch)) \
	$($(target)_LNK_ORDERDEPS.$(bld_trg)) \
	$($(target)_LNK_ORDERDEPS.$(bld_type)) \
	$($(target)_LNK_ORDERDEPS)

# Adjust paths if we got a default path.
ifneq ($(defpath),)
 local libpath    := $(abspathex $(libpath),$(defpath))
 local deps       := $(abspathex $(deps),$(defpath))
 local orderdeps  := $(abspathex $(orderdeps),$(defpath))
 othersrc := $(abspathex $(othersrc),$(defpath))
 # libs are not subject to this because of the the -l<lib> stuff. Use $(<target>_DEFPATH)/lib if relative to current dir!
endif

# Custom pre-link actions.
ifdef $(target)_PRE_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type)
 local pre_cmds := $($(target)_PRE_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type))
else ifdef $(target)_PRE_CMDS.$(bld_trg).$(bld_trg_arch)
 local pre_cmds := $($(target)_PRE_CMDS.$(bld_trg).$(bld_trg_arch))
else ifdef $(target)_PRE_CMDS.$(bld_trg).$(bld_type)
 local pre_cmds := $($(target)_PRE_CMDS.$(bld_trg).$(bld_type))
else ifdef $(target)_PRE_CMDS.$(bld_trg_arch)
 local pre_cmds := $($(target)_PRE_CMDS.$(bld_trg_arch))
else ifdef $(target)_PRE_CMDS.$(bld_trg)
 local pre_cmds := $($(target)_PRE_CMDS.$(bld_trg))
else ifdef $(target)_PRE_CMDS.$(bld_type)
 local pre_cmds := $($(target)_PRE_CMDS.$(bld_type))
else ifdef $(target)_PRE_CMDS
 local pre_cmds := $($(target)_PRE_CMDS)
else ifdef PRE_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type)
 local pre_cmds := $(PRE_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type))
else ifdef PRE_CMDS.$(bld_trg).$(bld_trg_arch)
 local pre_cmds := $(PRE_CMDS.$(bld_trg).$(bld_trg_arch))
else ifdef PRE_CMDS.$(bld_trg).$(bld_type)
 local pre_cmds := $(PRE_CMDS.$(bld_trg).$(bld_type))
else ifdef PRE_CMDS.$(bld_trg_arch)
 local pre_cmds := $(PRE_CMDS.$(bld_trg_arch))
else ifdef PRE_CMDS.$(bld_trg)
 local pre_cmds := $(PRE_CMDS.$(bld_trg))
else ifdef PRE_CMDS.$(bld_type)
 local pre_cmds := $(PRE_CMDS.$(bld_type))
else
 local pre_cmds := $(PRE_CMDS)
endif

# Custom post-link actions.
ifdef $(target)_POST_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type)
 local post_cmds := $($(target)_POST_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type))
else ifdef $(target)_POST_CMDS.$(bld_trg).$(bld_trg_arch)
 local post_cmds := $($(target)_POST_CMDS.$(bld_trg).$(bld_trg_arch))
else ifdef $(target)_POST_CMDS.$(bld_trg).$(bld_type)
 local post_cmds := $($(target)_POST_CMDS.$(bld_trg).$(bld_type))
else ifdef $(target)_POST_CMDS.$(bld_trg_arch)
 local post_cmds := $($(target)_POST_CMDS.$(bld_trg_arch))
else ifdef $(target)_POST_CMDS.$(bld_trg)
 local post_cmds := $($(target)_POST_CMDS.$(bld_trg))
else ifdef $(target)_POST_CMDS.$(bld_type)
 local post_cmds := $($(target)_POST_CMDS.$(bld_type))
else ifdef $(target)_POST_CMDS
 local post_cmds := $($(target)_POST_CMDS)
else ifdef POST_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type)
 local post_cmds := $(POST_CMDS.$(bld_trg).$(bld_trg_arch).$(bld_type))
else ifdef POST_CMDS.$(bld_trg).$(bld_trg_arch)
 local post_cmds := $(POST_CMDS.$(bld_trg).$(bld_trg_arch))
else ifdef POST_CMDS.$(bld_trg).$(bld_type)
 local post_cmds := $(POST_CMDS.$(bld_trg).$(bld_type))
else ifdef POST_CMDS.$(bld_trg_arch)
 local post_cmds := $(POST_CMDS.$(bld_trg_arch))
else ifdef POST_CMDS.$(bld_trg)
 local post_cmds := $(POST_CMDS.$(bld_trg))
else ifdef POST_CMDS.$(bld_type)
 local post_cmds := $(POST_CMDS.$(bld_type))
else
 local post_cmds := $(POST_CMDS)
endif

# eliminate this guy?
local objs = $($(target)_2_OBJS)

# installation targets
ifeq ($(strip $($(target)_NOINST) $($(target)_NOINST.$(bld_trg)) $($(target)_NOINST.$(bld_trg).$(bld_trg_arch)) $($(target)_NOINST.$(bld_trg).$(bld_trg_arch).$(bld_type))  $($(target)_NOINST.$(bld_trg_arch)) $($(target)_NOINST.$(bld_trg_cpu)) $($(target)_NOINST.$(bld_trg_type))),)
 ifneq ($(strip $($(target)_INST.$(bld_trg).$(bld_trg_arch).$(bld_type))),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg).$(bld_trg_arch).$(bld_type)))
 else ifneq ($(strip $($(target)_INST.$(bld_trg).$(bld_trg_arch))),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg).$(bld_trg_arch)))
 else ifneq ($(strip $($(target)_INST.$(bld_trg).$(bld_type))),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg).$(bld_type)))
 else ifneq ($(strip $($(target)_INST.$(bld_trg_arch))),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg_arch)))
 else ifneq ($(strip $($(target)_INST.$(bld_trg))),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_trg)))
 else ifneq ($(strip $($(target)_INST.$(bld_type))),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST.$(bld_type)))
 else ifneq ($(strip $($(target)_INST)),)
  local inst := $(addprefix $(PATH_INS)/,$($(target)_INST))
 else
  local inst := $(definst)/
 endif
 INSTARGET_$(target) := $(patsubst %/,%/$(notdir $(out)),$(inst))
 ifdef KBUILD_DO_AUTO_INSTALL
  $(typevar)  += $(INSTARGET_$(target))
 else
  $(typevar)  += $(out)
 endif
 local mode := $(firstword \
 	$($(target)_MODE.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
 	$($(target)_MODE.$(bld_trg).$(bld_trg_arch)) \
 	$($(target)_MODE.$(bld_trg).$(bld_type)) \
 	$($(target)_MODE.$(bld_trg_arch)) \
 	$($(target)_MODE.$(bld_trg)) \
 	$($(target)_MODE.$(bld_type)) \
 	$($(target)_MODE) )
 local uid := $(firstword \
 	$($(target)_UID.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
 	$($(target)_UID.$(bld_trg).$(bld_trg_arch)) \
 	$($(target)_UID.$(bld_trg).$(bld_type)) \
 	$($(target)_UID.$(bld_trg_arch)) \
 	$($(target)_UID.$(bld_trg)) \
 	$($(target)_UID.$(bld_type)) \
 	$($(target)_UID) )
 local gid := $(firstword \
 	$($(target)_GID.$(bld_trg).$(bld_trg_arch).$(bld_type)) \
 	$($(target)_GID.$(bld_trg).$(bld_trg_arch)) \
 	$($(target)_GID.$(bld_trg).$(bld_type)) \
 	$($(target)_GID.$(bld_trg_arch)) \
 	$($(target)_GID.$(bld_trg)) \
 	$($(target)_GID.$(bld_type)) \
 	$($(target)_GID) )

 # generate the install rule
$(eval $(def_link_install_rule))

else # NOINST
 INSTARGET_$(target) :=
 $(typevar)  += $(out)
endif # NOINST

# dependency file
local dep := $(outbase)$(SUFF_DEP)
ifndef NO_LINK_CMDS_DEPS
 _DEPFILES_INCLUDED += $(dep)
 ifdef KB_HAVE_INCLUDEDEP_QUEUE
  includedep-queue $(dep)
 else
  includedep $(dep)
 endif
endif

# check that the tool is defined.
ifndef TOOL_$(tool)_$(tool_do)_CMDS
$(warning kBuild: tools: \
	1 $($(target)_$(source)TOOL.$(bld_trg).$(bld_trg_arch)) \
	2 $($(target)_$(source)TOOL.$(bld_trg)) \
	3 $($(target)_$(source)TOOL) \
	4 $($(target)_TOOL.$(bld_trg).$(bld_trg_arch)) \
	5 $($(target)_TOOL.$(bld_trg)) \
	6 $($(target)_TOOL) \
	7 $($(source)TOOL.$(bld_trg).$(bld_trg_arch)) \
	8 $($(source)TOOL.$(bld_trg)) \
	9 $($(source)TOOL) \
	10 $(TOOL.$(bld_trg).$(bld_trg_arch)) \
	11 $(TOOL.$(bld_trg)) \
	12 $(TOOL) )
$(error kBuild: TOOL_$(tool)_$(tool_do)_CMDS isn't defined! target=$(target) )
endif

# call the tool
local cmds   := $(TOOL_$(tool)_$(tool_do)_CMDS)
ifneq ($(pre_cmds),)
 local cmds  := $(TAB)$(pre_cmds)$(NL)$(TAB)$(cmds)
endif
ifneq ($(post_cmds),)
 local cmds  := $(cmds)$(NL)$(TAB)$(post_cmds)
endif
$(target)_2_OUTPUT := $(TOOL_$(tool)_$(tool_do)_OUTPUT)
$(target)_2_OUTPUT_MAYBE := $(TOOL_$(tool)_$(tool_do)_OUTPUT_MAYBE)
$(target)_2_DEPEND := $(TOOL_$(tool)_$(tool_do)_DEPEND) $(deps) $($(target)_2_OBJS)
$(target)_2_DEPORD := $(TOOL_$(tool)_$(tool_do)_DEPORD) $(dirdep) $(orderdeps)

# generate the link rule.
$(eval $(def_link_rule))


# Update globals.
_OBJS += $($(target)_2_OBJS)
_OUT_FILES += $($(target)_2_OUTPUT) $($(target)_2_OUTPUT_MAYBE) $(out)
_CLEAN_FILES += $($(target)_CLEAN) $($(target)_CLEAN.$(bld_trg)) $($(target)_CLEAN.$(bld_trg).$(bld_trg_arch)) $($(target)_CLEAN.$(bld_trg_arch)) $($(target)_CLEAN.$(bld_trg_cpu)) $($(target)_CLEAN.$(bld_type))
_DIRS += $($(target)_BLDDIRS) $($(target)_BLDDIRS.$(bld_trg)) $($(target)_BLDDIRS.$(bld_trg).$(bld_trg_arch)) $($(target)_BLDDIRS.$(bld_trg_arch)) $($(target)_BLDDIRS.$(bld_trg_cpu)) $($(target)_BLDDIRS.$(bld_type))
_INSTALLS_FILES += $(INSTARGET_$(target))

endef # def_link_common
$(eval-opt-var def_link_common)


#
# BLDPROGS
#

## Build program (one).
# @param    $(target)   Normalized target (program) name.
define def_bldprog

# set NOINST if not forced installation.
ifndef $(target)_INST
$(target)_NOINST := 1
endif

# do the usual stuff.
$(evalval def_link_common)

endef

# Process build programs.
EXT     := EXE
EXTPRE  := HOST
tool_do := LINK_PROGRAM
definst := $(PATH_BIN)
typevar := _BLDPROGS
mode    := 0755
bld_trg_base_var := PLATFORM
$(foreach target, $(_ALL_BLDPROGS), $(evalval def_bldprog))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done build program targets)
endif


#
# DLLS
#

# Process dlls
EXT     := DLL
EXTPRE  :=
tool_do := LINK_DLL
definst := $(PATH_DLL)
typevar := _DLLS
mode    := 0644
bld_trg_base_var := TARGET
$(foreach target, $(_ALL_DLLS), $(evalval def_link_common))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done dll targets)
endif


#
# IMPORT LIBRARIES
#
#   - On OS/2 and windows these are libraries.
#   - On other platforms they are fake DLLs.
#
EXTPRE  :=
typevar := _IMPORT_LIBS
mode    := 0644
bld_trg_base_var := TARGET
ifeq ($(filter-out nt os2 win win64 win32,$(KBUILD_TARGET)),)
 EXT     := LIB
 tool_do := LINK_LIBRARY
 definst := $(PATH_LIB)
 $(foreach target, $(_ALL_IMPORT_LIBS), $(evalval def_lib))
else
 EXT     := DLL
 tool_do := LINK_DLL
 definst := $(PATH_DLL)
 $(foreach target, $(_ALL_IMPORT_LIBS), $(evalval def_link_common))
endif

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done import library targets)
endif


#
# PROGRAMS
#

# Process programs
EXT     := EXE
EXTPRE  :=
tool_do := LINK_PROGRAM
definst := $(PATH_BIN)
typevar := _PROGRAMS
mode    := 0755
bld_trg_base_var := TARGET
$(foreach target, $(_ALL_PROGRAMS), $(evalval def_link_common))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done program targets)
endif


#
# SYSMODS
#

# Process sysmods
EXT     := SYS
EXTPRE  :=
tool_do := LINK_SYSMOD
definst := $(PATH_SYS)
typevar := _SYSMODS
mode    := 0644
bld_trg_base_var := TARGET
$(foreach target, $(_ALL_SYSMODS), $(evalval def_link_common))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done sysmod targets)
endif


#
# MISCBINS
#

# Process MISCBINS
EXT     := BIN
EXTPRE  :=
tool_do := LINK_MISCBIN
definst := $(PATH_BIN)
typevar := _MISCBINS
mode    := 0644
bld_trg_base_var := TARGET
$(foreach target, $(_ALL_MISCBINS), $(evalval def_link_common))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done misc binary targets)
endif


#
# OTHERS
#
_OTHERS = $(OTHERS) $(OTHERS.$(KBUILD_TARGET)) $(OTHERS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))


#
# INSTALLS
#

## generate the install rule
define def_install_src_rule
# the install rule
$(insdst) : $(srcsrc) | $(call DIRDEP,$(dir $(insdst)))
	%$$(call MSG_INST_FILE,$(srcsrc),$(insdst))
	$$(QUIET)$(inscmd)
endef
$(eval-opt-var def_install_src_rule)

## install one file
define def_install_src

# deal with '=>' in the source file name.
ifeq ($(src),=>)
 $(error kBuild: Install target '$(target)' has a bad source specifier containing '=>' without any file names)
endif
ifeq ($(substr $(src),1,2),=>)
 $(warning kBuild: Install target '$(target)' has a bad source specifier: $(src))
endif
ifeq ($(substr $(src),-2),=>)
 $(warning kBuild: Install target '$(target)' has a bad source specifier: $(src))
endif
local srcdst := $(subst =>, ,$(src))
local srcsrc := $(firstword $(srcdst))
local srcdstdir := $(dir $(word 2,$(srcdst)))
local srcdst := $(word $(words $(srcdst)),$(srcdst))

# _INSTFUN
ifdef $(srcsrc)_INSTFUN
 local instfun := $(srcsrc)_INSTFUN
else ifdef $(target)_INSTFUN
 local instfun := $(target)_INSTFUN
else
 local instfun := _INSTALL_FILE
endif

# _INST
ifdef $(srcsrc)_INST
 local inst := $(patsubst %/,%,$($(srcsrc)_INST))/$(dir $(srcdstdir))
else ifdef $(target)_INST
 local inst := $(patsubst %/,%,$($(target)_INST))/$(dir $(srcdstdir))
else
 local inst := $(dir $(srcdstdir))
endif

# calc target
local insdst := $(call $(instfun),$(srcdst),$(target),$(inst),$(PATH_INS))
#$(warning instfun=$(instfun) srcdst=$(srcdst) target=$(target) inst=$(inst) => insdst=$(insdst))

# mode, uid and gid
local mode := $(firstword \
	$($(target)_$(srcsrc)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcsrc)_MODE.$(bld_trg)) \
	$($(target)_$(srcsrc)_MODE) \
	$($(target)_$(srcdst)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcdst)_MODE.$(bld_trg)) \
	$($(target)_$(srcdst)_MODE) \
	$($(srcsrc)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(srcsrc)_MODE.$(bld_trg)) \
	$($(srcsrc)_MODE) \
	$($(srcdst)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(srcdst)_MODE.$(bld_trg)) \
	$($(srcdst)_MODE) \
	$($(target)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_MODE.$(bld_trg)) \
	$($(target)_MODE))
local uid := $(firstword \
	$($(target)_$(srcsrc)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcsrc)_UID.$(bld_trg)) \
	$($(target)_$(srcsrc)_UID) \
	$($(target)_$(srcdst)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcdst)_UID.$(bld_trg)) \
	$($(target)_$(srcdst)_UID) \
	$($(srcsrc)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(srcsrc)_UID.$(bld_trg)) \
	$($(srcsrc)_UID) \
	$($(srcdst)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(srcdst)_UID.$(bld_trg)) \
	$($(srcdst)_UID) \
	$($(target)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_UID.$(bld_trg)) \
	$($(target)_UID))
local gid := $(firstword \
	$($(target)_$(srcsrc)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcsrc)_GID.$(bld_trg)) \
	$($(target)_$(srcsrc)_GID) \
	$($(target)_$(srcdst)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcdst)_GID.$(bld_trg)) \
	$($(target)_$(srcdst)_GID) \
	$($(srcsrc)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(srcsrc)_GID.$(bld_trg)) \
	$($(srcsrc)_GID) \
	$($(srcdst)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(srcdst)_GID.$(bld_trg)) \
	$($(srcdst)_GID) \
	$($(target)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_GID.$(bld_trg)) \
	$($(target)_GID))
local flags := \
	$($(target)_IFFLAGS) \
	$($(target)_IFFLAGS.$(bld_trg)) \
	$($(target)_IFFLAGS.$(bld_trg).$(bld_trg_arch)) \
	$($(srcdst)_IFFLAGS) \
	$($(srcdst)_IFFLAGS.$(bld_trg)) \
	$($(srcdst)_IFFLAGS.$(bld_trg).$(bld_trg_arch)) \
	$($(srcsrc)_IFFLAGS) \
	$($(srcsrc)_IFFLAGS.$(bld_trg)) \
	$($(srcsrc)_IFFLAGS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcdst)_IFFLAGS) \
	$($(target)_$(srcdst)_IFFLAGS.$(bld_trg)) \
	$($(target)_$(srcdst)_IFFLAGS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcsrc)_IFFLAGS) \
	$($(target)_$(srcsrc)_IFFLAGS.$(bld_trg)) \
	$($(target)_$(srcsrc)_IFFLAGS.$(bld_trg).$(bld_trg_arch))
clean_files += \
	$($(srcdst)_CLEAN) \
	$($(srcdst)_CLEAN.$(bld_trg)) \
	$($(srcdst)_CLEAN.$(bld_trg).$(bld_trg_arch)) \
	$($(srcsrc)_CLEAN) \
	$($(srcsrc)_CLEAN.$(bld_trg)) \
	$($(srcsrc)_CLEAN.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcdst)_CLEAN) \
	$($(target)_$(srcdst)_CLEAN.$(bld_trg)) \
	$($(target)_$(srcdst)_CLEAN.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(srcsrc)_CLEAN) \
	$($(target)_$(srcsrc)_CLEAN.$(bld_trg)) \
	$($(target)_$(srcsrc)_CLEAN.$(bld_trg).$(bld_trg_arch))


# Adjust the source if we got a default PATH. (This must be done this late!)
local defpath := $(firstword $($(target)_PATH) $($(target)_DEFPATH))
ifneq ($(defpath),)
 local srcsrc := $(abspathex $(srcsrc),$(defpath))
endif

# create the command
ifdef $(srcsrc)_INSTALLER
 local inscmd := $(call $(srcsrc)_INSTALLER,$(srcsrc),$(insdst),$(target),$(flags))
else ifdef $(target)_INSTALLER
 local inscmd := $(call $(target)_INSTALLER,$(srcsrc),$(insdst),$(target),$(flags))
else
 local inscmd := $$(INSTALL)\
		$(if $(uid),-o $(uid))\
		$(if $(gid),-g $(gid))\
		$(if $(mode),-m $(mode))\
		$(flags) -- \
		$(srcsrc) $(insdst)
endif

# generate the rule (need double evaluation here)
$(eval $(def_install_src_rule))

INSTARGET_$(target) += $(insdst)
endef # def_install_src
$(eval-opt-var def_install_src)


## generate the symlink rule
define def_install_symlink_rule
# the install rule
$(insdst) : | $(call DIRDEP,$(dir $(insdst)))
	%$$(call MSG_INST_SYM,$(insdst),$(symdst))
	$$(QUIET)$$(RM) -f -- $$@
	$$(QUIET)$$(LN_SYMLINK) $(symdst) $(insdst)
endef # def_install_symlink_rule
$(eval-opt-var def_install_symlink_rule)

## create one symlink
define def_install_symlink

# deal with '=>' in the source file name.
local symdst := $(subst =>, ,$(src))
local symlnk := $(firstword $(symdst))
local symdst := $(word $(words $(symdst)),$(symdst))

# _INSTFUN
ifdef $(symlnk)_INSTFUN
 local instfun := $(symlnk)_INSTFUN
else ifdef $(target)_INSTFUN
 local instfun := $(target)_INSTFUN
else
 local instfun := _INSTALL_FILE
endif

# _INST
ifdef $(symlnk)_INST
 local inst := $(patsubst %/,%,$($(symlnk)_INST))/$(dir $(symlnk))
else ifdef $(target)_INST
 local inst := $(patsubst %/,%,$($(target)_INST))/$(dir $(symlnk))
else
 local inst := $(dir $(symlnk))
endif

# calc target
local insdst := $(call $(instfun),$(symlnk),$(target),$(inst),$(PATH_INS))
#$(warning symlnk=$(symlnk) symdst=$(symdst) insdst=$(insdst) instfun=$(instfun) inst='$(inst)')

# generate the rule (need double evaluation here)
$(eval $(def_install_symlink_rule))

INSTARGET_$(target) += $(insdst)
endef # def_install_symlink
$(optmize def_install_symlink)


## generate the install rule
define def_install_directory_rule
# the install rule
$(insdst):
	%$$(call MSG_INST_DIR,$(insdst))
	$$(QUIET)$$(INSTALL) -d \
		$(if $(uid),-o $(uid))\
		$(if $(gid),-g $(gid))\
		$(if $(mode),-m $(mode))\
		$(flags) -- \
		$(insdst)

.NOTPARALLEL: $(insdst)
endef # def_install_directory_rule
$(eval-opt-var def_install_directory_rule)


## create one directory
define def_install_directory

# _INST
ifdef $(directory)_INST
 local inst := $(PATH_INS)/$(patsubst %/,%,$($(directory)_INST))
else ifdef $(target)_INST
 local inst := $(PATH_INS)/$(patsubst %/,%,$($(target)_INST))
else
 local inst := $(PATH_INS)
endif

local mode := $(firstword \
	$($(target)_$(directory)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(directory)_MODE.$(bld_trg)) \
	$($(target)_$(directory)_MODE) \
	$($(directory)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(directory)_MODE.$(bld_trg)) \
	$($(directory)_MODE) \
	$($(target)_MODE.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_MODE.$(bld_trg)) \
	$($(target)_MODE))
local uid := $(firstword \
	$($(target)_$(directory)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(directory)_UID.$(bld_trg)) \
	$($(target)_$(directory)_UID) \
	$($(directory)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(directory)_UID.$(bld_trg)) \
	$($(directory)_UID) \
	$($(target)_UID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_UID.$(bld_trg)) \
	$($(target)_UID))
local gid := $(firstword \
	$($(target)_$(directory)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(directory)_GID.$(bld_trg)) \
	$($(target)_$(directory)_GID) \
	$($(directory)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(directory)_GID.$(bld_trg)) \
	$($(directory)_GID) \
	$($(target)_GID.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_GID.$(bld_trg)) \
	$($(target)_GID))
local flags := \
	$($(target)_IDFLAGS)\
	$($(target)_IDFLAGS.$(bld_trg)) \
	$($(target)_IDFLAGS.$(bld_trg).$(bld_trg_arch)) \
	$($(directory)_IDFLAGS) \
	$($(directory)_IDFLAGS.$(bld_trg)) \
	$($(directory)_IDFLAGS.$(bld_trg).$(bld_trg_arch)) \
	$($(target)_$(directory)_IDFLAGS) \
	$($(target)_$(directory)_IDFLAGS.$(bld_trg)) \
	$($(target)_$(directory)_IDFLAGS.$(bld_trg).$(bld_trg_arch))

local insdst := $(inst)/$(directory)/
#$(warning directory=$(directory) inst=$(inst) insdst=$(insdst) mode=$(mode) gid=$(gid) uid=$(uid))

# generate the rule (need double evaluation here)
$(eval $(def_install_directory_rule))

INSTARGET_DIRS_$(target) += $(insdst)
endef # def_install_directory
$(eval-opt-var def_install_directory)


## process one install target.
define def_install
# the basics.
local bld_type  := $(firstword $($(target)_BLD_TYPE)     $(KBUILD_TYPE))
local bld_trg   := $(firstword $($(target)_BLD_TRG)      $(KBUILD_TARGET))
local bld_trg_arch:= $(firstword $($(target)_BLD_TRG_ARCH) $(KBUILD_TARGET_ARCH))
local bld_trg_cpu := $(firstword $($(target)_BLD_TRG_CPU)  $(KBUILD_TARGET_CPU))

INSTARGET_$(target) := $($(target)_GOALS)
INSTARGET_DIRS_$(target) :=
local outbase := $(call TARGET_BASE,$(target),$(target))
$(target)_0_OUTDIR := $(patsubst %/,%,$(dir $(outbase)))
PATH_$(target) := $($(target)_0_OUTDIR)

local clean_files := $($(target)_CLEAN) $($(target)_CLEAN.$(bld_trg)) $($(target)_CLEAN.$(bld_trg).$(bld_trg_arch)) $($(target)_CLEAN.$(bld_trg_arch)) $($(target)_CLEAN.$(bld_trg_cpu)) $($(target)_CLEAN.$(bld_type))

$(foreach directory,$($(target)_DIRS) $($(target)_DIRS.$(bld_trg)) $($(target)_DIRS.$(bld_trg).$(bld_trg_arch)) $($(target)_DIRS.$(bld_trg_arch)) $($(target)_DIRS.$(bld_trg_cpu)) $($(target)_DIRS.$(bld_type)), \
	$(evalval def_install_directory))

$(foreach src,$($(target)_SOURCES) $($(target)_SOURCES.$(bld_trg)) $($(target)_SOURCES.$(bld_trg).$(bld_trg_arch)) $($(target)_SOURCES.$(bld_trg_arch)) $($(target)_SOURCES.$(bld_trg_cpu)) $($(target)_SOURCES.$(bld_type)), \
	$(evalval def_install_src))

$(foreach src,$($(target)_SYMLINKS) $($(target)_SYMLINKS.$(bld_trg)) $($(target)_SYMLINKS.$(bld_trg).$(bld_trg_arch)) $($(target)_SYMLINKS.$(bld_trg_arch)) $($(target)_SYMLINKS.$(bld_trg_cpu)) $($(target)_SYMLINKS.$(bld_type)), \
	$(evalval def_install_symlink))

# the collection target
local clean_files  += $(PATH_TARGET)/$(target).ins
$(target)_1_TARGET := $(PATH_TARGET)/$(target).ins
TARGET_$(target)   := $($(target)_1_TARGET)
$($(target)_1_TARGET): $$(INSTARGET_$(target)) | $$(INSTARGET_DIRS_$(target)) $(call DIRDEP,$(PATH_TARGET))
	@$(QUIET2)$(APPEND) $@

$(target): $$($(target)_1_TARGET)

_INSTALLS += $($(target)_1_TARGET)
_INSTALLS_FILES += $(INSTARGET_$(target))
_INSTALLS_DIRS += $(INSTARGET_DIRS_$(target))
_CLEAN_FILES += $(clean_files)
_DIRS += $($(target)_0_OUTDIR) $($(target)_BLDDIRS) $($(target)_BLDDIRS.$(bld_trg)) $($(target)_BLDDIRS.$(bld_trg).$(bld_trg_arch)) $($(target)_BLDDIRS.$(bld_trg_arch)) $($(target)_BLDDIRS.$(bld_trg_cpu)) $($(target)_BLDDIRS.$(bld_type))
endef # def_install
$(eval-opt-var def_install)

## process all install targets
$(foreach target, $(_ALL_INSTALLS), \
	$(evalvalctx def_install))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done install targets)
endif

# Some introspection targets that can be useful for package maintainers.
.PHONY: kbuild-show-install-files kbuild-show-install-dirs
kbuild-show-install-files::
	$(addprefix $(NL)$(TAB)$(QUIET)$(ECHO) , $(subst $(PATH_INS)/,,$(_INSTALLS_FILES)))

kbuild-show-install-dirs::
	$(addprefix $(NL)$(TAB)$(QUIET)$(ECHO) , $(subst $(PATH_INS)/,,$(_INSTALLS_DIRS)))


#
# TESTING
#
_TESTING += $(TESTING) $(TESTING.$(KBUILD_TARGET)) $(TESTING.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)) $(TESTING.$(KBUILD_TARGET_ARCH)) $(TESTING.$(KBUILD_TARGET_CPU))


#
# PACKING
#
_PACKING += $(PACKING) $(PACKING.$(KBUILD_TARGET)) $(PACKING.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)) $(PACKING.$(KBUILD_TARGET_ARCH)) $(PACKING.$(KBUILD_TARGET_CPU))


#
# DOCS
#


#
# DIRECTORIES
#
_DIR_ALL := $(sort $(addsuffix /,$(patsubst %/,%,$(_DIRS))) $(dir $(_OUT_FILES) $(_OBJS) $(_INSTALLS_FILES)))
$(foreach directory,$(_INSTALLS_DIRS), $(eval _DIR_ALL := $(filter-out $(directory),$(_DIR_ALL))))


define def_mkdir_rule
$(directory):
	%$$(call MSG_MKDIR,$$@)
	$$(QUIET)$$(MKDIR) -p -- $$@
endef

$(foreach directory,$(_DIR_ALL),$(eval $(def_mkdir_rule)))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done directories)
endif


#
# NOTHING
#
do-nothing:
	%$(call MSG_NOTHING)
ifdef KBUILD_PROFILE_SELF
	@$(ECHO) 'prof: $(call _KBUILD_FMT_ELAPSED_EX, $(nanots ), $(_KBUILD_TS_HEADER_START)) - $(call _KBUILD_FMT_ELAPSED_EX, $(nanots ), $(_KBUILD_TS_PREV)) - executing $@'
 ifeq ($(KBUILD_PROFILE_SELF),2)
	@$(ECHO) 'stat: $(make-stats )'
 endif
endif


#
# CLEAN UP
#
do-clean:
	%$(call MSG_CLEAN)
	$(QUIET)$(RM) -f -- $(_OUT_FILES) $(_OBJS) $(_DEPFILES) $(_DEPFILES_INCLUDED) $(_CLEAN_FILES) $(OTHER_CLEAN)
	$(QUIET)$(RMDIR) -p --ignore-fail-on-non-empty --ignore-fail-on-not-exist -- $(rsort $(dir $(_OUT_FILES) $(_OBJS) $(_DEPFILES) $(_DEPFILES_INCLUDED) $(_CLEAN_FILES) $(OTHER_CLEAN)))



#
# PASSES (including directory and makefile walking)
#

#
# First, check whether we need to order the passes explicitly or not.
# This depends on whether we're a leaf makefile or not. A leaf will
# know all its dependencies, while a recursive one relies on the
# order sub-directories and other makefiles are executed it.
#

## Setup a pass and check for optimizations.
# @param	$(PASS)		Uppercase pass name.
define def_pass_setup_and_optimize

# The setup. ## @todo This is looks a bit weird...
ifndef SUBDIRS_$(PASS)
 SUBDIRS_$(PASS)          := $(SUBDIRS)          $(SUBDIRS.$(KBUILD_TARGET))          $(SUBDIRS.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))
endif
ifndef SUBDIRS_AFTER_$(PASS)
 SUBDIRS_AFTER_$(PASS)    := $(SUBDIRS_AFTER)    $(SUBDIRS_AFTER.$(KBUILD_TARGET))    $(SUBDIRS_AFTER.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))
endif
ifndef MAKEFILES_BEFORE_$(PASS)
 MAKEFILES_BEFORE_$(PASS) := $(MAKEFILES_BEFORE) $(MAKEFILES_BEFORE.$(KBUILD_TARGET)) $(MAKEFILES_BEFORE.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))
endif
ifndef MAKEFILES_AFTER_$(PASS)
 MAKEFILES_AFTER_$(PASS)  := $(MAKEFILES_AFTER)  $(MAKEFILES_AFTER.$(KBUILD_TARGET))  $(MAKEFILES_AFTER.$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))
endif

# The check.
ifeq ($(_KBUILD_STRICT_PASS_ORDER),nonstrict)
 ifneq ($(strip \
          $(SUBDIRS_$(PASS))          $(SUBDIRS_$(PASS).$(KBUILD_TARGET))          $(SUBDIRS_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))           \
          $(MAKEFILES_BEFORE_$(PASS)) $(MAKEFILES_BEFORE_$(PASS).$(KBUILD_TARGET)) $(MAKEFILES_BEFORE_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))  \
          $(SUBDIRS_AFTER_$(PASS))    $(SUBDIRS_AFTER_$(PASS).$(KBUILD_TARGET))    $(SUBDIRS_AFTER_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))     \
          $(MAKEFILES_AFTER_$(PASS))  $(MAKEFILES_AFTER_$(PASS).$(KBUILD_TARGET))  $(MAKEFILES_AFTER_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))   \
         ),)
  _KBUILD_STRICT_PASS_ORDER := strict
 endif
endif # _KBUILD_STRICT_PASS_ORDER == nonstrict
endef # def_pass_setup_and_optimize
$(eval-opt-var def_pass_setup_and_optimize)

## PASS: Setup & optimization.
# Check if we can apply the non-strict pass order optimzation (no SUBDIRS_* and MAKEFILES_*),
# and set up the pass specific variables as we go along.
_KBUILD_STRICT_PASS_ORDER := nonstrict
$(foreach PASS, $(PASSES), $(evalval def_pass_setup_and_optimize))
#$ (error _KBUILD_STRICT_PASS_ORDER=$(_KBUILD_STRICT_PASS_ORDER))

ifeq ($(_KBUILD_STRICT_PASS_ORDER),strict)
 if !defined(KBUILD_SAFE_PARALLEL) || "$(KMK_OPT_JOBS)" == "1"
_KBUILD_STRICT_PASS_ORDER := strict_unsafe
 endif
endif


## Subdir
# @param	$(pass)		Lowercase pass name.
# @param	$(PASS)		Uppercase pass name.
# @param	$(subdir)	Subdirectory
# @param	$(tag)		tag to attach to the rule name.
define def_pass_subdir
pass_$(pass)$(tag):: $(dep)
	+ $$(QUIET)$$(MAKE) -C $(subdir) -f $$(notdir $$(firstword $$(wildcard $$(addprefix $(subdir)/,$$(DEFAULT_MAKEFILE))))) pass_$(pass)
endef

## Submakefile
# @param	$(pass)		Lowercase pass name.
# @param	$(PASS)		Uppercase pass name.
# @param	$(makefile)	Makefile.
# @param	$(tag)		tag to attach to the rule name.
define def_pass_makefile
pass_$(pass)$(tag):: $(dep)
	+ $$(QUIET)$$(MAKE) -C $(patsubst %/,%,$(dir $(makefile))) -f $(notdir $(makefile)) pass_$(pass)
endef

## Execute a pass, strict order.
# @param	$(pass)		Lowercase pass name.
# @param	$(PASS)		Uppercase pass name.
define def_pass_strict
$(eval tag:=_before)
$(eval dep:= )
$(foreach subdir,  $(SUBDIRS_$(PASS))          $(SUBDIRS_$(PASS).$(KBUILD_TARGET))          $(SUBDIRS_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))         ,$(eval $(def_pass_subdir)))
$(foreach makefile,$(MAKEFILES_BEFORE_$(PASS)) $(MAKEFILES_BEFORE_$(PASS).$(KBUILD_TARGET)) $(MAKEFILES_BEFORE_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)),$(eval $(def_pass_makefile)))

$(eval tag:=_after)
$(eval dep:=pass_$(pass)_doit)
$(foreach subdir,  $(SUBDIRS_AFTER_$(PASS))    $(SUBDIRS_AFTER_$(PASS).$(KBUILD_TARGET))    $(SUBDIRS_AFTER_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))   ,$(eval $(def_pass_subdir)))
$(foreach makefile,$(MAKEFILES_AFTER_$(PASS))  $(MAKEFILES_AFTER_$(PASS).$(KBUILD_TARGET))  $(MAKEFILES_AFTER_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)) ,$(eval $(def_pass_makefile)))

.NOTPARALLEL: pass_$(pass) pass_$(pass)_before pass_$(pass)_after pass_$(pass)_this
.PHONY:       pass_$(pass) pass_$(pass)_before pass_$(pass)_after pass_$(pass)_this pass_$(pass)_doit
pass_$(pass)_doit:      $(PASS_$(PASS)_trgs) $(foreach var,$(PASS_$(PASS)_vars),$($(var)))
pass_$(pass)_this:      pass_$(pass)_before
	+ $$(QUIET)$$(MAKE) -f $$(MAKEFILE) pass_$(pass)_doit
pass_$(pass)_after::    pass_$(pass)_this
pass_$(pass):           pass_$(pass)_after
#$ (warning pass=$(pass) PASS=$(PASS): $(PASS_$(PASS)_trgs) $(PASS_$(PASS)_trgs) $(foreach var,$(PASS_$(PASS)_vars),$($(var))))
endef # def_pass_strict
$(eval-opt-var def_pass_strict)

## Execute a pass, strict order.
# @param	$(pass)		Lowercase pass name.
# @param	$(PASS)		Uppercase pass name.
define def_pass_strict_unsafe
$(eval tag:=_before)
$(eval dep:= )
$(foreach subdir,  $(SUBDIRS_$(PASS))          $(SUBDIRS_$(PASS).$(KBUILD_TARGET))          $(SUBDIRS_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))         ,$(eval $(def_pass_subdir)))
$(foreach makefile,$(MAKEFILES_BEFORE_$(PASS)) $(MAKEFILES_BEFORE_$(PASS).$(KBUILD_TARGET)) $(MAKEFILES_BEFORE_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)),$(eval $(def_pass_makefile)))

$(eval tag:=_after)
$(eval dep:=pass_$(pass)_doit)
$(foreach subdir,  $(SUBDIRS_AFTER_$(PASS))    $(SUBDIRS_AFTER_$(PASS).$(KBUILD_TARGET))    $(SUBDIRS_AFTER_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH))   ,$(eval $(def_pass_subdir)))
$(foreach makefile,$(MAKEFILES_AFTER_$(PASS))  $(MAKEFILES_AFTER_$(PASS).$(KBUILD_TARGET))  $(MAKEFILES_AFTER_$(PASS).$(KBUILD_TARGET).$(KBUILD_TARGET_ARCH)) ,$(eval $(def_pass_makefile)))

.PHONY:       pass_$(pass) pass_$(pass)_before pass_$(pass)_after pass_$(pass)_doit
.NOTPARALLEL: pass_$(pass) pass_$(pass)_before pass_$(pass)_after pass_$(pass)_doit
pass_$(pass)_doit: pass_$(pass)_before \
		$(PASS_$(PASS)_trgs) $(foreach var,$(PASS_$(PASS)_vars),$($(var)))
pass_$(pass): \
		pass_$(pass)_before \
		pass_$(pass)_doit \
		pass_$(pass)_after
#$ (warning pass=$(pass) PASS=$(PASS): $(PASS_$(PASS)_trgs) $(PASS_$(PASS)_trgs) $(foreach var,$(PASS_$(PASS)_vars),$($(var))))
endef # def_pass_strict_unsafe
$(eval-opt-var def_pass_strict_unsafe)

## Execute a pass, non-strict pass ordering.
# @param	$(pass)		Lowercase pass name.
# @param	$(PASS)		Uppercase pass name.
define def_pass_nonstrict
.PHONY:       pass_$(pass) pass_$(pass)_before pass_$(pass)_after pass_$(pass)_doit
pass_$(pass)_doit: $(PASS_$(PASS)_trgs) $(foreach var,$(PASS_$(PASS)_vars),$$$$($(var)))
pass_$(pass):	pass_$(pass)_doit
endef # def_pass_nonstrict

## PASS: rules
# Generate the rules for the defined passes.
$(foreach PASS, $(PASSES), \
	$(eval pass := $(PASS_$(PASS)_pass)) \
	$(eval $(def_pass_$(_KBUILD_STRICT_PASS_ORDER))))


## Pass order, strict.
# @param	$(pass)		Current pass name.
# @param	$(prev_pass)	The previous pass name.
define def_pass_order_strict
.PHONY:       pass_$(pass)_order
.NOTPARALLEL: pass_$(pass)_order
pass_$(pass)_order: $(pass_prev)
	%$$(call MSG_PASS,$$(if $$(PASS_$(PASS)),$$(PASS_$(PASS)),$(pass)))
	+ $$(QUIET)$$(MAKE) -f $$(MAKEFILE) pass_$(pass)
$(eval pass_prev := pass_$(pass)_order)
endef # def_pass_order_strict
$(eval-opt-var def_pass_order_strict)

## Pass order, strict unsafe.
# @param	$(pass)		Current pass name.
# @param	$(prev_pass)	The previous pass name.
define def_pass_order_strict_unsafe
.NOTPARALLEL: pass_$(pass)_order pass_$(pass)_banner
.PHONY:       pass_$(pass)_order pass_$(pass)_banner
pass_$(pass)_banner: $(pass_prev)
	%$$(call MSG_PASS,$$(if $$(PASS_$(PASS)),$$(PASS_$(PASS)),$(pass)))
pass_$(pass)_order:  $(pass_prev) \
		pass_$(pass)_banner \
		pass_$(pass)
$(eval pass_prev := pass_$(pass)_order)
endef # def_pass_order_strict_unsafe
$(eval-opt-var def_pass_order_strict_unsafe)

## Pass order, non-strict.
# @param	$(pass)		Current pass name.
# @param	$(prev_pass)	The previous pass name.
define def_pass_order_nonstrict
.PHONY:       pass_$(pass)_order pass_$(pass)_banner
pass_$(pass)_banner:
	%$$(call MSG_PASS,$$(if $$(PASS_$(PASS)),$$(PASS_$(PASS)),$(pass)))
pass_$(pass)_order: \
		$(pass_prev) \
		pass_$(pass)_banner \
		pass_$(pass)
$(eval pass_prev := pass_$(pass)_order)
endef # def_pass_order_nonstrict
$(eval-opt-var def_pass_order_nonstrict)

## PASS: order
# Use dependencies to ensure correct pass order.
pass_prev :=
$(foreach PASS,$(DEFAULT_PASSES),\
	$(eval pass := $(PASS_$(PASS)_pass)) \
	$(eval $(def_pass_order_$(_KBUILD_STRICT_PASS_ORDER))))

ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, done passes)
endif

# Some common pass aliases
ifndef KBUILD_NO_PASS_ALIASES
.PHONY:  clean
clean:   pass_clean

.PHONY:  nothing
nothing: pass_nothing

.PHONY:  packing
packing: pass_packing

 ifndef KBUILD_NO_TESTING_PASS_ALIASES
.PHONY:  check
check::  pass_testing

.PHONY:  test
test::   pass_testing
 endif # KBUILD_NO_TESTING_PASS_ALIASES
endif # KBUILD_NO_PASS_ALIASES


#
# THE MAIN RULES
#
all_recursive: $(pass_prev)

rebuild: clean
	+ $(MAKE) -f $(firstword $(MAKEFILE_LIST)) all_recursive

# @todo make this a non-default pass!
uninstall::
	$(RM) -f -- $(_INSTALLS_FILES)

install:: pass_installs

# misc shortcuts (use secondary expansion here to save strcache[file] space).
targets:   bldprogs libraries dlls programs sysmods miscbins others installs
objects:   $$(_OBJS)
bldprogs:  $$(_BLDPROGS)
libraries: $$(_LIBS) $$(_IMPORT_LIBS) $$(_OTHER_LIBRARIES)
dlls:      $$(_DLLS)
programs:  $$(_PROGRAMS)
sysmods:   $$(_SYSMODS)
miscbins:  $$(_MISCBINS)
others:    $$(_OTHERS)
installs:  $$(_INSTALLS) $$(_INSTALLS_DIRS) $$(_INSTALLS_FILES)



#
# kBuild debugging stuff.
#
## @todo this doesn't work. Move to a debug unit and expand it.
show_targets:
	@$(foreach target, $(_ALL_TARGETS),\
	@$(ECHO) "target: $(target)" $(NLTAB)\
	@$(ECHO) "  $(target)_0_OUTDIR=$($(target)_0_OUTDIR)" $(NLTAB)\
	@$(ECHO) "  $(target)_1_TARGET=$($(target)_1_TARGET)" $(NLTAB)\
	@$(ECHO) "  INSTARGET_$(target)=$(INSTARGET_$(target))" $(NLTAB)\
$(foreach prop,$(PROPS_SINGLE) $(PROPS_ACCUMULATE_L) $(PROPS_ACCUMULATE_R) 2_OBJS CLEAN, \
	$(eval _tmp:=$(firstword $($(target)_BLD_TRG) $(KBUILD_TARGET))) \
	$(if $($(target)_$(prop).$(_tmp)),\
		@$(ECHO) "  $(target)_$(prop).$(_tmp)=$($(target)_$(prop).$(_tmp))" $(NLTAB)) \
	$(if $($(target)_$(prop)), $(NLTAB)@$(ECHO) "  $(target)_$(prop)=$($(target)_$(prop))" $(NLTAB)) \
)\
$(foreach prop,$(PROPS_DEFERRED), \
	$(eval _tmp:=$(firstword $($(target)_BLD_TRG) $(KBUILD_TARGET))) \
	$(if $(value $(target)_$(prop).$(_tmp)),\
		@$(ECHO) '  $(target)_$(prop).$(_tmp)=$(value $(TARGET)_$(prop).$(_tmp))' $(NLTAB)) \
	$(if $(value $(target)_$(prop)), $(NLTAB)@$(ECHO) '  $(target)_$(prop)=$(value $(target)_$(prop))' $(NLTAB)) \
))



#
# Include dependency files.
#
ifdef _DEPFILES
 # TODO: first works the second doesn't, provided _KB_INCLUDE_DEPS is undefined:
 #   if "$(_KB_INCLUDE_DEPS)" == "1"
 #   if $(_KB_INCLUDE_DEPS) == "1"

 ifdef KB_HAVE_INCLUDEDEP_QUEUE
  includedep-queue $(_DEPFILES)
 else
  $(foreach dep, $(_DEPFILES), $(eval includedep $(dep)))
 endif
endif


ifdef KBUILD_PROFILE_SELF
 $(evalcall def_profile_self, end of footer.kmk)
 _KBUILD_TS_FOOTER_END := $(_KBUILD_TS_PREV)

 ifneq ($(KBUILD_PROFILE_SELF),0)
  $(info prof: ALL=$(words $(_ALL_TARGETS)) BLDPROGS=$(words $(_ALL_BLDPROGS)) LIBRARIES=$(words $(_ALL_LIBRARIES)) IMPORT_LIBS=$(words $(IMPORT_LIBS)) DLLS=$(words $(DLLS)) PROGRAMS=$(words $(_ALL_PROGRAMS)) )
  $(info prof: SYSMODS=$(words $(_ALL_SYSMODS)) MISCBINS=$(words $(_ALL_MISCBINS)) OTHERS=$(words $(_ALL_OTHERS)) INSTALLS=$(words $(_ALL_INSTALLS)) FETCHES=$(words $(_ALL_FETCHES)) PACKING=$(words $(_PACKING)) TESTING=$(words $(TESTING)) )
  $(info prof: DIRS=$(words $(_DIR_ALL)) TOOLS=$(words $(_TOOLS)) SDKS=$(words $(_SDKS)) USES=$(words $(_USES)) OUT_FILES=$(words $(_OUT_FILES)) OBJS=$(words $(_OBJS)) CLEAN_FILES=$(words $(CLEAN_FILES) $(OTHER_CLEAN)) )
  $(info prof: DEPFILES_INCLUDED=$(words $(_DEPFILES_INCLUDED)) DEPFILES=$(words $(_DEPFILES)) MAKEFILES=$(words $(MAKEFILE_LIST)) )
 endif
endif


# end-of-file-content
__footer_kmk__ := target
endif # __footer_kmk__

